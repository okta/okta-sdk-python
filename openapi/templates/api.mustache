# The Okta software accompanied by this notice is provided pursuant to the following terms:
# Copyright Â© 2025-Present, Okta, Inc.
# Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License.
# You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
# Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and limitations under the License.
# coding: utf-8

{{>partial_header}}
import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated
from urllib.parse import urlencode

{{#imports}}
{{import}}
{{/imports}}

from {{packageName}}.models.success import Success
from {{packageName}}.api_client import ApiClient, RequestSerialized
from {{packageName}}.api_response import ApiResponse
from {{packageName}}.rest import RESTResponseType, RESTResponse
from {{packageName}}.utils import format_url
from {{packageName}}.constants import find_app_model, find_factor_model, find_policy_rule_model, find_policy_model

{{#operations}}
class {{classname}}(ApiClient):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, configuration) -> None:
        super().__init__(configuration=configuration)

{{#operation}}


    @validate_call
    async def {{operationId}}{{>partial_api_args}} -> {{{returnType}}}{{^returnType}}None{{/returnType}}:
{{>partial_api}}
        form = {}
        keep_empty_params = False

        request, error = await self._request_executor.create_request(
            method, url, body, header_params, form, keep_empty_params=keep_empty_params
        )

        if error:
            {{#returnType}}
            if {{returnType}} is Success:
                return (None, error)
            else:
                return (None, None, error)
            {{/returnType}}
            {{^returnType}}
            return (None, error)
            {{/returnType}}

        {{#returnType}}
        if {{returnType}} is Success:
            response, response_body, error = await self._request_executor.execute(request)
        else:
            response, response_body, error = await self._request_executor.execute(request, {{returnBaseType}})
        {{/returnType}}
        {{^returnType}}
        response, response_body, error = await self._request_executor.execute(request)
        {{/returnType}}

        if response_body == '' or response.status == 204:
            response_data = RESTResponse(response)
            resp = ApiResponse(
                status_code=response_data.status,
                data=None,
                headers=response_data.getheaders(),
                raw_data=b''
            )
            return (None, resp, None)
        else:
            response_body = response_body.encode('utf-8')

            if error:
                {{#returnType}}
                if {{returnType}} is Success:
                    return (response, error)
                else:
                    return (None, response, error)
                {{/returnType}}
                {{^returnType}}
                return (response, error)
                {{/returnType}}

            response_data = RESTResponse(response)
            response_data.read(response_body)
            resp = self.response_deserialize(
                response_data=response_data,
                response_types_map=_response_types_map,
            )
            return (resp.data, resp, None)


    @validate_call
    async def {{operationId}}_with_http_info{{>partial_api_args}} -> {{{returnType}}}{{^returnType}}None{{/returnType}}:
{{>partial_api}}
        form = {}
        keep_empty_params = False

        request, error = await self._request_executor.create_request(
            method, url, body, header_params, form, keep_empty_params=keep_empty_params
        )

        if error:
            {{#returnType}}
            if {{returnType}} is Success:
                return (None, error)
            else:
                return (None, None, error)
            {{/returnType}}
            {{^returnType}}
            return (None, error)
            {{/returnType}}

        {{#returnType}}
        if {{returnType}} is Success:
            response, response_body, error = await self._request_executor.execute(request)
        else:
            response, response_body, error = await self._request_executor.execute(request, {{returnBaseType}})
        {{/returnType}}
        {{^returnType}}
        response, response_body, error = await self._request_executor.execute(request)
        {{/returnType}}

        if response_body == '' or response.status == 204:
            response_data = RESTResponse(response)
            resp = ApiResponse(
                status_code=response_data.status,
                data=None,
                headers=response_data.getheaders(),
                raw_data=b''
            )
            return (None, resp, None)
        else:
            response_body = response_body.encode('utf-8')

            if error:
                {{#returnType}}
                if {{returnType}} is Success:
                    return (response, error)
                else:
                    return (None, response, error)
                {{/returnType}}
                {{^returnType}}
                return (response, error)
                {{/returnType}}

            response_data = RESTResponse(response)
            response_data.read(response_body)
            resp = self.response_deserialize(
                response_data=response_data,
                response_types_map=_response_types_map,
            )
            return (resp.data, resp, None)


    @validate_call
    async def {{operationId}}_without_preload_content{{>partial_api_args}} -> {{{returnType}}}{{^returnType}}None{{/returnType}}:
{{>partial_api}}
        form = {}
        keep_empty_params = False

        request, error = await self._request_executor.create_request(
            method, url, body, header_params, form, keep_empty_params=keep_empty_params
        )

        if error:
            {{#returnType}}
            if {{returnType}} is Success:
                return (None, error)
            else:
                return (None, None, error)
            {{/returnType}}
            {{^returnType}}
            return (None, error)
            {{/returnType}}

        {{#returnType}}
        if {{returnType}} is Success:
            response, response_body, error = await self._request_executor.execute(request)
        else:
            response, response_body, error = await self._request_executor.execute(request, {{returnBaseType}})
        {{/returnType}}
        {{^returnType}}
        response, response_body, error = await self._request_executor.execute(request)
        {{/returnType}}

        if response_body == '' or response.status == 204:
            response_data = RESTResponse(response)
            resp = ApiResponse(
                status_code=response_data.status,
                data=None,
                headers=response_data.getheaders(),
                raw_data=b''
            )
            return (None, resp, None)
        else:
            response_body = response_body.encode('utf-8')

            if error:
                {{#returnType}}
                if {{returnType}} is Success:
                    return (response, error)
                else:
                    return (None, response, error)
                {{/returnType}}
                {{^returnType}}
                return (response, error)
                {{/returnType}}

            response_data = RESTResponse(response)
            response_data.read(response_body)
            resp = self.response_deserialize(
                response_data=response_data,
                response_types_map=_response_types_map,
            )
            return (resp.data, resp, None)


    def _{{operationId}}_serialize(
        self,
        {{#allParams}}
        {{paramName}},
        {{/allParams}}
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        {{#servers.0}}
        _hosts = [{{#servers}}
            '{{{url}}}'{{^-last}},{{/-last}}{{/servers}}
        ]
        _host = _hosts[_host_index]
        {{/servers.0}}
        {{^servers.0}}
        _host = None
        {{/servers.0}}

        _collection_formats: Dict[str, str] = {
            {{#allParams}}
            {{#isArray}}
            '{{baseName}}': '{{collectionFormat}}',
            {{/isArray}}
            {{/allParams}}
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
{{#pathParams}}
        if {{paramName}} is not None:
            _path_params['{{baseName}}'] = {{paramName}}{{#isEnumRef}}.value{{/isEnumRef}}
{{/pathParams}}
        # process the query parameters
{{#queryParams}}
        if {{paramName}} is not None:
            {{#isDateTime}}
            if isinstance({{paramName}}, datetime):
                _query_params.append(
                    (
                        '{{baseName}}',
                        {{paramName}}.strftime(
                            self.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('{{baseName}}', {{paramName}}))
            {{/isDateTime}}
            {{#isDate}}
            if isinstance({{paramName}}, date):
                _query_params.append(
                    (
                        '{{baseName}}',
                        {{paramName}}.strftime(
                            self.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('{{baseName}}', {{paramName}}))
            {{/isDate}}
            {{^isDateTime}}{{^isDate}}
            _query_params.append(('{{baseName}}', {{paramName}}{{#isEnumRef}}.value{{/isEnumRef}}))
            {{/isDate}}{{/isDateTime}}
{{/queryParams}}
        # process the header parameters
{{#headerParams}}
        if {{paramName}} is not None:
            _header_params['{{baseName}}'] = {{paramName}}
{{/headerParams}}
        # process the form parameters
{{#formParams}}
        if {{paramName}} is not None:
            {{#isFile}}
            _files['{{{baseName}}}'] = {{paramName}}
            {{/isFile}}
            {{^isFile}}
            _form_params.append(('{{{baseName}}}', {{paramName}}))
            {{/isFile}}
{{/formParams}}
        # process the body parameter
{{#bodyParam}}
        if {{paramName}} is not None:
            {{#isBinary}}
            # convert to byte array if the input is a file name (str)
            if isinstance({{paramName}}, str):
                with open({{paramName}}, "rb") as _fp:
                    _body_params = _fp.read()
            else:
                _body_params = {{paramName}}
            {{/isBinary}}
            {{^isBinary}}
            _body_params = {{paramName}}
            {{/isBinary}}
{{/bodyParam}}

        {{#constantParams}}
        {{#isQueryParam}}
        # Set client side default value of Query Param "{{baseName}}".
        _query_params['{{baseName}}'] = {{#_enum}}'{{{.}}}'{{/_enum}}
        {{/isQueryParam}}
        {{#isHeaderParam}}
        # Set client side default value of Header Param "{{baseName}}".
        _header_params['{{baseName}}'] = {{#_enum}}'{{{.}}}'{{/_enum}}
        {{/isHeaderParam}}
        {{/constantParams}}

        {{#hasProduces}}
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.select_header_accept(
            [{{#produces}}
                '{{{mediaType}}}'{{^-last}}, {{/-last}}{{/produces}}
            ]
        )
        {{/hasProduces}}

        {{#hasConsumes}}
        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.select_header_content_type(
                    [{{#consumes}}
                        '{{{mediaType}}}'{{^-last}}, {{/-last}}{{/consumes}}
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type
        {{/hasConsumes}}

        # authentication setting
        _auth_settings: List[str] = [{{#authMethods}}
            '{{name}}'{{^-last}}, {{/-last}}{{/authMethods}}
        ]

        return self.param_serialize(
            method='{{httpMethod}}',
            resource_path='{{{path}}}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


{{/operation}}
{{/operations}}
