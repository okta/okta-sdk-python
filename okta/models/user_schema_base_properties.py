# The Okta software accompanied by this notice is provided pursuant to the following terms:
# Copyright Â© 2025-Present, Okta, Inc.
# Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
# License.
# You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
# Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS
# IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and limitations under the License.
# coding: utf-8

"""
Okta Admin Management

Allows customers to easily access the Okta Management APIs

The version of the OpenAPI document: 5.1.0
Contact: devex-public@okta.com
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations

import json
import pprint
import re  # noqa: F401
from typing import Any, ClassVar, Dict, List
from typing import Optional, Set

from pydantic import BaseModel, ConfigDict, Field
from typing_extensions import Self

from okta.models.user_schema_attribute import UserSchemaAttribute


class UserSchemaBaseProperties(BaseModel):
    """
    UserSchemaBaseProperties
    """  # noqa: E501

    city: Optional[UserSchemaAttribute] = Field(
        default=None,
        description="City or locality component of the user's address (`locality`)",
    )
    cost_center: Optional[UserSchemaAttribute] = Field(
        default=None,
        description="Name of a cost center assigned to the user",
        alias="costCenter",
    )
    country_code: Optional[UserSchemaAttribute] = Field(
        default=None,
        description="Country name component of the user's address (`country`.) This property uses [ISO 3166-1 alpha 2 "
        '"short" code format](https://tools.ietf.org/html/draft-ietf-scim-core-schema-22#ref-ISO3166).',
        alias="countryCode",
    )
    department: Optional[UserSchemaAttribute] = Field(
        default=None, description="Name of the user's department"
    )
    display_name: Optional[UserSchemaAttribute] = Field(
        default=None,
        description="Name of the user, suitable for display to end users",
        alias="displayName",
    )
    division: Optional[UserSchemaAttribute] = Field(
        default=None, description="Name of the user's division"
    )
    email: Optional[UserSchemaAttribute] = Field(
        default=None,
        description="Primary email address of the user. This property is formatted according to [RFC 5322 Section 3.2.3]("
        "https://datatracker.ietf.org/doc/html/rfc5322#section-3.2.3).",
    )
    employee_number: Optional[UserSchemaAttribute] = Field(
        default=None,
        description="Organization or company assigned unique identifier for the user",
        alias="employeeNumber",
    )
    first_name: Optional[UserSchemaAttribute] = Field(
        default=None,
        description="Given name of the user (`givenName`)",
        alias="firstName",
    )
    honorific_prefix: Optional[UserSchemaAttribute] = Field(
        default=None,
        description="Honorific prefix(es) of the user or title in most Western languages",
        alias="honorificPrefix",
    )
    honorific_suffix: Optional[UserSchemaAttribute] = Field(
        default=None,
        description="Honorific suffix(es) of the user",
        alias="honorificSuffix",
    )
    last_name: Optional[UserSchemaAttribute] = Field(
        default=None,
        description="Family name of the user (`familyName`)",
        alias="lastName",
    )
    locale: Optional[UserSchemaAttribute] = Field(
        default=None,
        description="User's default location for purposes of localizing items such as currency, date time format, "
        "numerical representations, and so on.  A locale value is a concatenation of the ISO 639-1 two-letter "
        "language code, an underscore, and the ISO 3166-1 two-letter country code. For example: `en_US` "
        "specifies the language English and country US. This value is `en_US` by default.",
    )
    login: Optional[UserSchemaAttribute] = Field(
        default=None,
        description="Unique identifier for the user (`userName`)  The login property is validated according to its pattern "
        "attribute, which is a string. By default, the attribute is null. When the attribute is null, "
        "the username is required to be formatted as an email address as defined by [RFC 6531 Section 3.3]("
        "http://tools.ietf.org/html/rfc6531#section-3.3). The pattern can be set through the API to one of the "
        'following forms. (The Admin Console provides access to the same forms.)   * A login pattern of `".+"` '
        "indicates that there is no restriction on usernames. Any non-empty, unique value is permitted, "
        "and the minimum length of five isn't enforced. In this case, usernames don't need to include the `@` "
        "character. If a name does include `@`, the portion ahead of the `@` can be used for logging in, "
        'provided it identifies a unique user within the org.   * A login pattern of the form `"[...]+"` '
        "indicates that usernames must only contain characters from the set given between the brackets. The "
        "enclosing brackets and final `+` are required for this form. Character ranges can be indicated using "
        "hyphens. To include the hyphen itself in the allowed set, the hyphen must appear first. Any characters "
        "in the set except the hyphen, a-z, A-Z, and 0-9 must be preceded by a backslash (`\\`). For example, "
        '`"[a-z13579\\.]+"` would restrict usernames to lowercase letters, odd digits, and periods, '
        'while `"[-a-zA-Z0-9]+"` would allow basic alphanumeric characters and hyphens.',
    )
    manager: Optional[UserSchemaAttribute] = Field(
        default=None, description="The `displayName` of the user's manager"
    )
    manager_id: Optional[UserSchemaAttribute] = Field(
        default=None, description="The `id` of the user's manager", alias="managerId"
    )
    middle_name: Optional[UserSchemaAttribute] = Field(
        default=None, description="Middle name(s) of the user", alias="middleName"
    )
    mobile_phone: Optional[UserSchemaAttribute] = Field(
        default=None, description="Mobile phone number of the user", alias="mobilePhone"
    )
    nick_name: Optional[UserSchemaAttribute] = Field(
        default=None,
        description="Casual way to address the user in real life",
        alias="nickName",
    )
    organization: Optional[UserSchemaAttribute] = Field(
        default=None, description="Name of the user's organization"
    )
    postal_address: Optional[UserSchemaAttribute] = Field(
        default=None,
        description="Mailing address component of the user's address",
        alias="postalAddress",
    )
    preferred_language: Optional[UserSchemaAttribute] = Field(
        default=None,
        description="User's preferred written or spoken languages. This property is formatted according to [RFC 7231 Section "
        "5.3.5](https://tools.ietf.org/html/rfc7231#section-5.3.5).",
        alias="preferredLanguage",
    )
    primary_phone: Optional[UserSchemaAttribute] = Field(
        default=None,
        description="Primary phone number of the user, such as home number",
        alias="primaryPhone",
    )
    profile_url: Optional[UserSchemaAttribute] = Field(
        default=None,
        description="URL of the user's online profile (for example, a web page.) This property is formatted according to the "
        "[Relative Uniform Resource Locators specification]("
        "https://tools.ietf.org/html/draft-ietf-scim-core-schema-22#ref-ISO3166).",
        alias="profileUrl",
    )
    second_email: Optional[UserSchemaAttribute] = Field(
        default=None,
        description="Secondary email address of the user typically used for account recovery. This property is formatted "
        "according to [RFC 5322 Section 3.2.3](https://datatracker.ietf.org/doc/html/rfc5322#section-3.2.3).",
        alias="secondEmail",
    )
    state: Optional[UserSchemaAttribute] = Field(
        default=None,
        description="State or region component of the user's address (`region`)",
    )
    street_address: Optional[UserSchemaAttribute] = Field(
        default=None,
        description="Full street address component of the user's address",
        alias="streetAddress",
    )
    timezone: Optional[UserSchemaAttribute] = Field(
        default=None,
        description="User's time zone. This property is formatted according to the [IANA Time Zone database format]("
        "https://tools.ietf.org/html/rfc6557).",
    )
    title: Optional[UserSchemaAttribute] = Field(
        default=None, description='User\'s title, such as "Vice President"'
    )
    user_type: Optional[UserSchemaAttribute] = Field(
        default=None,
        description='Used to describe the organization to the user relationship such as "Employee" or "Contractor".  '
        "**Note:** The `userType` field is an arbitrary string value and isn't related to the newer [User "
        "Types](https://developer.okta.com/docs/api/openapi/okta-management/management/tag/UserType/) feature.",
        alias="userType",
    )
    zip_code: Optional[UserSchemaAttribute] = Field(
        default=None,
        description="ZIP code or postal code component of the user's address (`postalCode`)",
        alias="zipCode",
    )
    __properties: ClassVar[List[str]] = [
        "city",
        "costCenter",
        "countryCode",
        "department",
        "displayName",
        "division",
        "email",
        "employeeNumber",
        "firstName",
        "honorificPrefix",
        "honorificSuffix",
        "lastName",
        "locale",
        "login",
        "manager",
        "managerId",
        "middleName",
        "mobilePhone",
        "nickName",
        "organization",
        "postalAddress",
        "preferredLanguage",
        "primaryPhone",
        "profileUrl",
        "secondEmail",
        "state",
        "streetAddress",
        "timezone",
        "title",
        "userType",
        "zipCode",
    ]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of UserSchemaBaseProperties from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of city
        if self.city:
            if not isinstance(self.city, dict):
                _dict["city"] = self.city.to_dict()
            else:
                _dict["city"] = self.city

        # override the default output from pydantic by calling `to_dict()` of cost_center
        if self.cost_center:
            if not isinstance(self.cost_center, dict):
                _dict["costCenter"] = self.cost_center.to_dict()
            else:
                _dict["costCenter"] = self.cost_center

        # override the default output from pydantic by calling `to_dict()` of country_code
        if self.country_code:
            if not isinstance(self.country_code, dict):
                _dict["countryCode"] = self.country_code.to_dict()
            else:
                _dict["countryCode"] = self.country_code

        # override the default output from pydantic by calling `to_dict()` of department
        if self.department:
            if not isinstance(self.department, dict):
                _dict["department"] = self.department.to_dict()
            else:
                _dict["department"] = self.department

        # override the default output from pydantic by calling `to_dict()` of display_name
        if self.display_name:
            if not isinstance(self.display_name, dict):
                _dict["displayName"] = self.display_name.to_dict()
            else:
                _dict["displayName"] = self.display_name

        # override the default output from pydantic by calling `to_dict()` of division
        if self.division:
            if not isinstance(self.division, dict):
                _dict["division"] = self.division.to_dict()
            else:
                _dict["division"] = self.division

        # override the default output from pydantic by calling `to_dict()` of email
        if self.email:
            if not isinstance(self.email, dict):
                _dict["email"] = self.email.to_dict()
            else:
                _dict["email"] = self.email

        # override the default output from pydantic by calling `to_dict()` of employee_number
        if self.employee_number:
            if not isinstance(self.employee_number, dict):
                _dict["employeeNumber"] = self.employee_number.to_dict()
            else:
                _dict["employeeNumber"] = self.employee_number

        # override the default output from pydantic by calling `to_dict()` of first_name
        if self.first_name:
            if not isinstance(self.first_name, dict):
                _dict["firstName"] = self.first_name.to_dict()
            else:
                _dict["firstName"] = self.first_name

        # override the default output from pydantic by calling `to_dict()` of honorific_prefix
        if self.honorific_prefix:
            if not isinstance(self.honorific_prefix, dict):
                _dict["honorificPrefix"] = self.honorific_prefix.to_dict()
            else:
                _dict["honorificPrefix"] = self.honorific_prefix

        # override the default output from pydantic by calling `to_dict()` of honorific_suffix
        if self.honorific_suffix:
            if not isinstance(self.honorific_suffix, dict):
                _dict["honorificSuffix"] = self.honorific_suffix.to_dict()
            else:
                _dict["honorificSuffix"] = self.honorific_suffix

        # override the default output from pydantic by calling `to_dict()` of last_name
        if self.last_name:
            if not isinstance(self.last_name, dict):
                _dict["lastName"] = self.last_name.to_dict()
            else:
                _dict["lastName"] = self.last_name

        # override the default output from pydantic by calling `to_dict()` of locale
        if self.locale:
            if not isinstance(self.locale, dict):
                _dict["locale"] = self.locale.to_dict()
            else:
                _dict["locale"] = self.locale

        # override the default output from pydantic by calling `to_dict()` of login
        if self.login:
            if not isinstance(self.login, dict):
                _dict["login"] = self.login.to_dict()
            else:
                _dict["login"] = self.login

        # override the default output from pydantic by calling `to_dict()` of manager
        if self.manager:
            if not isinstance(self.manager, dict):
                _dict["manager"] = self.manager.to_dict()
            else:
                _dict["manager"] = self.manager

        # override the default output from pydantic by calling `to_dict()` of manager_id
        if self.manager_id:
            if not isinstance(self.manager_id, dict):
                _dict["managerId"] = self.manager_id.to_dict()
            else:
                _dict["managerId"] = self.manager_id

        # override the default output from pydantic by calling `to_dict()` of middle_name
        if self.middle_name:
            if not isinstance(self.middle_name, dict):
                _dict["middleName"] = self.middle_name.to_dict()
            else:
                _dict["middleName"] = self.middle_name

        # override the default output from pydantic by calling `to_dict()` of mobile_phone
        if self.mobile_phone:
            if not isinstance(self.mobile_phone, dict):
                _dict["mobilePhone"] = self.mobile_phone.to_dict()
            else:
                _dict["mobilePhone"] = self.mobile_phone

        # override the default output from pydantic by calling `to_dict()` of nick_name
        if self.nick_name:
            if not isinstance(self.nick_name, dict):
                _dict["nickName"] = self.nick_name.to_dict()
            else:
                _dict["nickName"] = self.nick_name

        # override the default output from pydantic by calling `to_dict()` of organization
        if self.organization:
            if not isinstance(self.organization, dict):
                _dict["organization"] = self.organization.to_dict()
            else:
                _dict["organization"] = self.organization

        # override the default output from pydantic by calling `to_dict()` of postal_address
        if self.postal_address:
            if not isinstance(self.postal_address, dict):
                _dict["postalAddress"] = self.postal_address.to_dict()
            else:
                _dict["postalAddress"] = self.postal_address

        # override the default output from pydantic by calling `to_dict()` of preferred_language
        if self.preferred_language:
            if not isinstance(self.preferred_language, dict):
                _dict["preferredLanguage"] = self.preferred_language.to_dict()
            else:
                _dict["preferredLanguage"] = self.preferred_language

        # override the default output from pydantic by calling `to_dict()` of primary_phone
        if self.primary_phone:
            if not isinstance(self.primary_phone, dict):
                _dict["primaryPhone"] = self.primary_phone.to_dict()
            else:
                _dict["primaryPhone"] = self.primary_phone

        # override the default output from pydantic by calling `to_dict()` of profile_url
        if self.profile_url:
            if not isinstance(self.profile_url, dict):
                _dict["profileUrl"] = self.profile_url.to_dict()
            else:
                _dict["profileUrl"] = self.profile_url

        # override the default output from pydantic by calling `to_dict()` of second_email
        if self.second_email:
            if not isinstance(self.second_email, dict):
                _dict["secondEmail"] = self.second_email.to_dict()
            else:
                _dict["secondEmail"] = self.second_email

        # override the default output from pydantic by calling `to_dict()` of state
        if self.state:
            if not isinstance(self.state, dict):
                _dict["state"] = self.state.to_dict()
            else:
                _dict["state"] = self.state

        # override the default output from pydantic by calling `to_dict()` of street_address
        if self.street_address:
            if not isinstance(self.street_address, dict):
                _dict["streetAddress"] = self.street_address.to_dict()
            else:
                _dict["streetAddress"] = self.street_address

        # override the default output from pydantic by calling `to_dict()` of timezone
        if self.timezone:
            if not isinstance(self.timezone, dict):
                _dict["timezone"] = self.timezone.to_dict()
            else:
                _dict["timezone"] = self.timezone

        # override the default output from pydantic by calling `to_dict()` of title
        if self.title:
            if not isinstance(self.title, dict):
                _dict["title"] = self.title.to_dict()
            else:
                _dict["title"] = self.title

        # override the default output from pydantic by calling `to_dict()` of user_type
        if self.user_type:
            if not isinstance(self.user_type, dict):
                _dict["userType"] = self.user_type.to_dict()
            else:
                _dict["userType"] = self.user_type

        # override the default output from pydantic by calling `to_dict()` of zip_code
        if self.zip_code:
            if not isinstance(self.zip_code, dict):
                _dict["zipCode"] = self.zip_code.to_dict()
            else:
                _dict["zipCode"] = self.zip_code

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of UserSchemaBaseProperties from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate(
            {
                "city": (
                    UserSchemaAttribute.from_dict(obj["city"])
                    if obj.get("city") is not None
                    else None
                ),
                "costCenter": (
                    UserSchemaAttribute.from_dict(obj["costCenter"])
                    if obj.get("costCenter") is not None
                    else None
                ),
                "countryCode": (
                    UserSchemaAttribute.from_dict(obj["countryCode"])
                    if obj.get("countryCode") is not None
                    else None
                ),
                "department": (
                    UserSchemaAttribute.from_dict(obj["department"])
                    if obj.get("department") is not None
                    else None
                ),
                "displayName": (
                    UserSchemaAttribute.from_dict(obj["displayName"])
                    if obj.get("displayName") is not None
                    else None
                ),
                "division": (
                    UserSchemaAttribute.from_dict(obj["division"])
                    if obj.get("division") is not None
                    else None
                ),
                "email": (
                    UserSchemaAttribute.from_dict(obj["email"])
                    if obj.get("email") is not None
                    else None
                ),
                "employeeNumber": (
                    UserSchemaAttribute.from_dict(obj["employeeNumber"])
                    if obj.get("employeeNumber") is not None
                    else None
                ),
                "firstName": (
                    UserSchemaAttribute.from_dict(obj["firstName"])
                    if obj.get("firstName") is not None
                    else None
                ),
                "honorificPrefix": (
                    UserSchemaAttribute.from_dict(obj["honorificPrefix"])
                    if obj.get("honorificPrefix") is not None
                    else None
                ),
                "honorificSuffix": (
                    UserSchemaAttribute.from_dict(obj["honorificSuffix"])
                    if obj.get("honorificSuffix") is not None
                    else None
                ),
                "lastName": (
                    UserSchemaAttribute.from_dict(obj["lastName"])
                    if obj.get("lastName") is not None
                    else None
                ),
                "locale": (
                    UserSchemaAttribute.from_dict(obj["locale"])
                    if obj.get("locale") is not None
                    else None
                ),
                "login": (
                    UserSchemaAttribute.from_dict(obj["login"])
                    if obj.get("login") is not None
                    else None
                ),
                "manager": (
                    UserSchemaAttribute.from_dict(obj["manager"])
                    if obj.get("manager") is not None
                    else None
                ),
                "managerId": (
                    UserSchemaAttribute.from_dict(obj["managerId"])
                    if obj.get("managerId") is not None
                    else None
                ),
                "middleName": (
                    UserSchemaAttribute.from_dict(obj["middleName"])
                    if obj.get("middleName") is not None
                    else None
                ),
                "mobilePhone": (
                    UserSchemaAttribute.from_dict(obj["mobilePhone"])
                    if obj.get("mobilePhone") is not None
                    else None
                ),
                "nickName": (
                    UserSchemaAttribute.from_dict(obj["nickName"])
                    if obj.get("nickName") is not None
                    else None
                ),
                "organization": (
                    UserSchemaAttribute.from_dict(obj["organization"])
                    if obj.get("organization") is not None
                    else None
                ),
                "postalAddress": (
                    UserSchemaAttribute.from_dict(obj["postalAddress"])
                    if obj.get("postalAddress") is not None
                    else None
                ),
                "preferredLanguage": (
                    UserSchemaAttribute.from_dict(obj["preferredLanguage"])
                    if obj.get("preferredLanguage") is not None
                    else None
                ),
                "primaryPhone": (
                    UserSchemaAttribute.from_dict(obj["primaryPhone"])
                    if obj.get("primaryPhone") is not None
                    else None
                ),
                "profileUrl": (
                    UserSchemaAttribute.from_dict(obj["profileUrl"])
                    if obj.get("profileUrl") is not None
                    else None
                ),
                "secondEmail": (
                    UserSchemaAttribute.from_dict(obj["secondEmail"])
                    if obj.get("secondEmail") is not None
                    else None
                ),
                "state": (
                    UserSchemaAttribute.from_dict(obj["state"])
                    if obj.get("state") is not None
                    else None
                ),
                "streetAddress": (
                    UserSchemaAttribute.from_dict(obj["streetAddress"])
                    if obj.get("streetAddress") is not None
                    else None
                ),
                "timezone": (
                    UserSchemaAttribute.from_dict(obj["timezone"])
                    if obj.get("timezone") is not None
                    else None
                ),
                "title": (
                    UserSchemaAttribute.from_dict(obj["title"])
                    if obj.get("title") is not None
                    else None
                ),
                "userType": (
                    UserSchemaAttribute.from_dict(obj["userType"])
                    if obj.get("userType") is not None
                    else None
                ),
                "zipCode": (
                    UserSchemaAttribute.from_dict(obj["zipCode"])
                    if obj.get("zipCode") is not None
                    else None
                ),
            }
        )
        return _obj
