# The Okta software accompanied by this notice is provided pursuant to the following terms:
# Copyright Â© 2025-Present, Okta, Inc.
# Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
# License.
# You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
# Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS
# IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and limitations under the License.
# coding: utf-8

"""
Okta Admin Management

Allows customers to easily access the Okta Management APIs

The version of the OpenAPI document: 5.1.0
Contact: devex-public@okta.com
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations

import json
import pprint
import re  # noqa: F401
from typing import Any, ClassVar, Dict, List
from typing import Optional, Set

from pydantic import BaseModel, ConfigDict, Field
from typing_extensions import Self

from okta.models.href_object_self_link import HrefObjectSelfLink
from okta.models.links_activate_activate import LinksActivateActivate
from okta.models.links_cancel_cancel import LinksCancelCancel
from okta.models.links_deactivate_deactivate import LinksDeactivateDeactivate
from okta.models.links_enroll_enroll import LinksEnrollEnroll
from okta.models.links_factor_factor import LinksFactorFactor
from okta.models.links_poll_poll import LinksPollPoll
from okta.models.links_qrcode_qrcode import LinksQrcodeQrcode
from okta.models.links_questions_question import LinksQuestionsQuestion
from okta.models.links_resend_resend import LinksResendResend
from okta.models.links_send_send import LinksSendSend
from okta.models.links_user_factors_user import LinksUserFactorsUser
from okta.models.links_verify_verify import LinksVerifyVerify


class UserFactorLinks(BaseModel):
    """
    UserFactorLinks
    """  # noqa: E501

    activate: Optional[LinksActivateActivate] = None
    cancel: Optional[LinksCancelCancel] = None
    deactivate: Optional[LinksDeactivateDeactivate] = None
    enroll: Optional[LinksEnrollEnroll] = None
    factor: Optional[LinksFactorFactor] = None
    poll: Optional[LinksPollPoll] = None
    qrcode: Optional[LinksQrcodeQrcode] = None
    question: Optional[LinksQuestionsQuestion] = None
    resend: Optional[LinksResendResend] = None
    send: Optional[LinksSendSend] = None
    var_self: Optional[HrefObjectSelfLink] = Field(default=None, alias="self")
    user: Optional[LinksUserFactorsUser] = None
    verify: Optional[LinksVerifyVerify] = None
    __properties: ClassVar[List[str]] = [
        "activate",
        "cancel",
        "deactivate",
        "enroll",
        "factor",
        "poll",
        "qrcode",
        "question",
        "resend",
        "send",
        "self",
        "user",
        "verify",
    ]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of UserFactorLinks from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of activate
        if self.activate:
            if not isinstance(self.activate, dict):
                _dict["activate"] = self.activate.to_dict()
            else:
                _dict["activate"] = self.activate

        # override the default output from pydantic by calling `to_dict()` of cancel
        if self.cancel:
            if not isinstance(self.cancel, dict):
                _dict["cancel"] = self.cancel.to_dict()
            else:
                _dict["cancel"] = self.cancel

        # override the default output from pydantic by calling `to_dict()` of deactivate
        if self.deactivate:
            if not isinstance(self.deactivate, dict):
                _dict["deactivate"] = self.deactivate.to_dict()
            else:
                _dict["deactivate"] = self.deactivate

        # override the default output from pydantic by calling `to_dict()` of enroll
        if self.enroll:
            if not isinstance(self.enroll, dict):
                _dict["enroll"] = self.enroll.to_dict()
            else:
                _dict["enroll"] = self.enroll

        # override the default output from pydantic by calling `to_dict()` of factor
        if self.factor:
            if not isinstance(self.factor, dict):
                _dict["factor"] = self.factor.to_dict()
            else:
                _dict["factor"] = self.factor

        # override the default output from pydantic by calling `to_dict()` of poll
        if self.poll:
            if not isinstance(self.poll, dict):
                _dict["poll"] = self.poll.to_dict()
            else:
                _dict["poll"] = self.poll

        # override the default output from pydantic by calling `to_dict()` of qrcode
        if self.qrcode:
            if not isinstance(self.qrcode, dict):
                _dict["qrcode"] = self.qrcode.to_dict()
            else:
                _dict["qrcode"] = self.qrcode

        # override the default output from pydantic by calling `to_dict()` of question
        if self.question:
            if not isinstance(self.question, dict):
                _dict["question"] = self.question.to_dict()
            else:
                _dict["question"] = self.question

        # override the default output from pydantic by calling `to_dict()` of resend
        if self.resend:
            if not isinstance(self.resend, dict):
                _dict["resend"] = self.resend.to_dict()
            else:
                _dict["resend"] = self.resend

        # override the default output from pydantic by calling `to_dict()` of send
        if self.send:
            if not isinstance(self.send, dict):
                _dict["send"] = self.send.to_dict()
            else:
                _dict["send"] = self.send

        # override the default output from pydantic by calling `to_dict()` of var_self
        if self.var_self:
            if not isinstance(self.var_self, dict):
                _dict["self"] = self.var_self.to_dict()
            else:
                _dict["self"] = self.var_self

        # override the default output from pydantic by calling `to_dict()` of user
        if self.user:
            if not isinstance(self.user, dict):
                _dict["user"] = self.user.to_dict()
            else:
                _dict["user"] = self.user

        # override the default output from pydantic by calling `to_dict()` of verify
        if self.verify:
            if not isinstance(self.verify, dict):
                _dict["verify"] = self.verify.to_dict()
            else:
                _dict["verify"] = self.verify

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of UserFactorLinks from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate(
            {
                "activate": (
                    LinksActivateActivate.from_dict(obj["activate"])
                    if obj.get("activate") is not None
                    else None
                ),
                "cancel": (
                    LinksCancelCancel.from_dict(obj["cancel"])
                    if obj.get("cancel") is not None
                    else None
                ),
                "deactivate": (
                    LinksDeactivateDeactivate.from_dict(obj["deactivate"])
                    if obj.get("deactivate") is not None
                    else None
                ),
                "enroll": (
                    LinksEnrollEnroll.from_dict(obj["enroll"])
                    if obj.get("enroll") is not None
                    else None
                ),
                "factor": (
                    LinksFactorFactor.from_dict(obj["factor"])
                    if obj.get("factor") is not None
                    else None
                ),
                "poll": (
                    LinksPollPoll.from_dict(obj["poll"])
                    if obj.get("poll") is not None
                    else None
                ),
                "qrcode": (
                    LinksQrcodeQrcode.from_dict(obj["qrcode"])
                    if obj.get("qrcode") is not None
                    else None
                ),
                "question": (
                    LinksQuestionsQuestion.from_dict(obj["question"])
                    if obj.get("question") is not None
                    else None
                ),
                "resend": (
                    LinksResendResend.from_dict(obj["resend"])
                    if obj.get("resend") is not None
                    else None
                ),
                "send": (
                    LinksSendSend.from_dict(obj["send"])
                    if obj.get("send") is not None
                    else None
                ),
                "self": (
                    HrefObjectSelfLink.from_dict(obj["self"])
                    if obj.get("self") is not None
                    else None
                ),
                "user": (
                    LinksUserFactorsUser.from_dict(obj["user"])
                    if obj.get("user") is not None
                    else None
                ),
                "verify": (
                    LinksVerifyVerify.from_dict(obj["verify"])
                    if obj.get("verify") is not None
                    else None
                ),
            }
        )
        return _obj
