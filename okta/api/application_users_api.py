# The Okta software accompanied by this notice is provided pursuant to the following terms:
# Copyright Â© 2025-Present, Okta, Inc.
# Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
# License.
# You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
# Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and limitations under the License.
# coding: utf-8

"""
Okta Admin Management

Allows customers to easily access the Okta Management APIs

The version of the OpenAPI document: 5.1.0
Contact: devex-public@okta.com
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""  # noqa: E501

from typing import Any, Dict, Tuple, Union
from typing import List, Optional

from pydantic import Field, StrictBool, StrictInt, StrictStr
from pydantic import validate_call, StrictFloat
from typing_extensions import Annotated

from okta.api_client import ApiClient, RequestSerialized
from okta.api_response import ApiResponse
from okta.models.app_user import AppUser
from okta.models.success import Success
from okta.rest import RESTResponse


class ApplicationUsersApi(ApiClient):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, configuration) -> None:
        super().__init__(configuration=configuration)

    @validate_call
    async def assign_user_to_application(
        self,
        app_id: Annotated[StrictStr, Field(description="ID of the Application")],
        app_user: AppUser,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppUser:
        """Assign a User

        Assigns a user to an app with credentials and an app-specific [profile](/openapi/okta-management/management/tag/Application/#tag/Application/operation/assignUserToApplication!c=200&path=profile&t=response). Profile mappings defined for the app are applied first before applying any profile properties that are specified in the request.  > **Notes:** > * You need to specify the `id` and omit the `credentials` parameter in the request body only for `signOnMode` or authentication schemes (`credentials.scheme`) that don't require credentials. > * You can only specify profile properties that aren't defined by profile mappings when Universal Directory is enabled. > * If your SSO app requires a profile but doesn't have provisioning enabled, you need to add a profile to the request body.

        :param app_id: ID of the Application (required)
        :type app_id: str
        :param app_user: (required)
        :type app_user: AppUser
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "AppUser",
            "400": "Error",
            "403": "Error",
            "404": "Error",
            "429": "Error",
        }

        method, url, header_params, body, post_params = (
            self._assign_user_to_application_serialize(
                app_id=app_id,
                app_user=app_user,
                _request_auth=_request_auth,
                _content_type=_content_type,
                _headers=_headers,
                _host_index=_host_index,
            )
        )

        form = {}
        keep_empty_params = False

        request, error = await self._request_executor.create_request(
            method, url, body, header_params, form, keep_empty_params=keep_empty_params
        )

        if error:
            if AppUser is Success:
                return (None, error)
            else:
                return (None, None, error)

        if AppUser is Success:
            response, response_body, error = await self._request_executor.execute(
                request
            )
        else:
            response, response_body, error = await self._request_executor.execute(
                request, AppUser
            )

        if response_body == "" or response.status == 204:
            response_data = RESTResponse(response)
            resp = ApiResponse(
                status_code=response_data.status,
                data=None,
                headers=response_data.getheaders(),
                raw_data=b"",
            )
            return (None, resp, None)
        else:
            response_body = response_body.encode("utf-8")

            if error:
                if AppUser is Success:
                    return (response, error)
                else:
                    return (None, response, error)

            response_data = RESTResponse(response)
            response_data.read(response_body)
            resp = self.response_deserialize(
                response_data=response_data,
                response_types_map=_response_types_map,
            )
            return (resp.data, resp, None)

    @validate_call
    async def assign_user_to_application_with_http_info(
        self,
        app_id: Annotated[StrictStr, Field(description="ID of the Application")],
        app_user: AppUser,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppUser:
        """Assign a User

        Assigns a user to an app with credentials and an app-specific [profile](/openapi/okta-management/management/tag/Application/#tag/Application/operation/assignUserToApplication!c=200&path=profile&t=response). Profile mappings defined for the app are applied first before applying any profile properties that are specified in the request.  > **Notes:** > * You need to specify the `id` and omit the `credentials` parameter in the request body only for `signOnMode` or authentication schemes (`credentials.scheme`) that don't require credentials. > * You can only specify profile properties that aren't defined by profile mappings when Universal Directory is enabled. > * If your SSO app requires a profile but doesn't have provisioning enabled, you need to add a profile to the request body.

        :param app_id: ID of the Application (required)
        :type app_id: str
        :param app_user: (required)
        :type app_user: AppUser
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "AppUser",
            "400": "Error",
            "403": "Error",
            "404": "Error",
            "429": "Error",
        }

        method, url, header_params, body, post_params = (
            self._assign_user_to_application_serialize(
                app_id=app_id,
                app_user=app_user,
                _request_auth=_request_auth,
                _content_type=_content_type,
                _headers=_headers,
                _host_index=_host_index,
            )
        )

        form = {}
        keep_empty_params = False

        request, error = await self._request_executor.create_request(
            method, url, body, header_params, form, keep_empty_params=keep_empty_params
        )

        if error:
            if AppUser is Success:
                return (None, error)
            else:
                return (None, None, error)

        if AppUser is Success:
            response, response_body, error = await self._request_executor.execute(
                request
            )
        else:
            response, response_body, error = await self._request_executor.execute(
                request, AppUser
            )

        if response_body == "" or response.status == 204:
            response_data = RESTResponse(response)
            resp = ApiResponse(
                status_code=response_data.status,
                data=None,
                headers=response_data.getheaders(),
                raw_data=b"",
            )
            return (None, resp, None)
        else:
            response_body = response_body.encode("utf-8")

            if error:
                if AppUser is Success:
                    return (response, error)
                else:
                    return (None, response, error)

            response_data = RESTResponse(response)
            response_data.read(response_body)
            resp = self.response_deserialize(
                response_data=response_data,
                response_types_map=_response_types_map,
            )
            return (resp.data, resp, None)

    @validate_call
    async def assign_user_to_application_without_preload_content(
        self,
        app_id: Annotated[StrictStr, Field(description="ID of the Application")],
        app_user: AppUser,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppUser:
        """Assign a User

        Assigns a user to an app with credentials and an app-specific [profile](/openapi/okta-management/management/tag/Application/#tag/Application/operation/assignUserToApplication!c=200&path=profile&t=response). Profile mappings defined for the app are applied first before applying any profile properties that are specified in the request.  > **Notes:** > * You need to specify the `id` and omit the `credentials` parameter in the request body only for `signOnMode` or authentication schemes (`credentials.scheme`) that don't require credentials. > * You can only specify profile properties that aren't defined by profile mappings when Universal Directory is enabled. > * If your SSO app requires a profile but doesn't have provisioning enabled, you need to add a profile to the request body.

        :param app_id: ID of the Application (required)
        :type app_id: str
        :param app_user: (required)
        :type app_user: AppUser
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "AppUser",
            "400": "Error",
            "403": "Error",
            "404": "Error",
            "429": "Error",
        }

        method, url, header_params, body, post_params = (
            self._assign_user_to_application_serialize(
                app_id=app_id,
                app_user=app_user,
                _request_auth=_request_auth,
                _content_type=_content_type,
                _headers=_headers,
                _host_index=_host_index,
            )
        )

        form = {}
        keep_empty_params = False

        request, error = await self._request_executor.create_request(
            method, url, body, header_params, form, keep_empty_params=keep_empty_params
        )

        if error:
            if AppUser is Success:
                return (None, error)
            else:
                return (None, None, error)

        if AppUser is Success:
            response, response_body, error = await self._request_executor.execute(
                request
            )
        else:
            response, response_body, error = await self._request_executor.execute(
                request, AppUser
            )

        if response_body == "" or response.status == 204:
            response_data = RESTResponse(response)
            resp = ApiResponse(
                status_code=response_data.status,
                data=None,
                headers=response_data.getheaders(),
                raw_data=b"",
            )
            return (None, resp, None)
        else:
            response_body = response_body.encode("utf-8")

            if error:
                if AppUser is Success:
                    return (response, error)
                else:
                    return (None, response, error)

            response_data = RESTResponse(response)
            response_data.read(response_body)
            resp = self.response_deserialize(
                response_data=response_data,
                response_types_map=_response_types_map,
            )
            return (resp.data, resp, None)

    def _assign_user_to_application_serialize(
        self,
        app_id,
        app_user,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if app_id is not None:
            _path_params["appId"] = app_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if app_user is not None:
            _body_params = app_user

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.select_header_accept(["application/json"])

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.select_header_content_type(
                ["application/json"]
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ["apiToken", "oauth2"]

        return self.param_serialize(
            method="POST",
            resource_path="/api/v1/apps/{appId}/users",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def get_application_user(
        self,
        app_id: Annotated[StrictStr, Field(description="ID of the Application")],
        user_id: StrictStr,
        expand: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppUser:
        """Retrieve an assigned User

        Retrieves a specific user assignment for app by `id`

        :param app_id: ID of the Application (required)
        :type app_id: str
        :param user_id: (required)
        :type user_id: str
        :param expand:
        :type expand: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "AppUser",
            "403": "Error",
            "404": "Error",
            "429": "Error",
        }

        method, url, header_params, body, post_params = (
            self._get_application_user_serialize(
                app_id=app_id,
                user_id=user_id,
                expand=expand,
                _request_auth=_request_auth,
                _content_type=_content_type,
                _headers=_headers,
                _host_index=_host_index,
            )
        )

        form = {}
        keep_empty_params = False

        request, error = await self._request_executor.create_request(
            method, url, body, header_params, form, keep_empty_params=keep_empty_params
        )

        if error:
            if AppUser is Success:
                return (None, error)
            else:
                return (None, None, error)

        if AppUser is Success:
            response, response_body, error = await self._request_executor.execute(
                request
            )
        else:
            response, response_body, error = await self._request_executor.execute(
                request, AppUser
            )

        if response_body == "" or response.status == 204:
            response_data = RESTResponse(response)
            resp = ApiResponse(
                status_code=response_data.status,
                data=None,
                headers=response_data.getheaders(),
                raw_data=b"",
            )
            return (None, resp, None)
        else:
            response_body = response_body.encode("utf-8")

            if error:
                if AppUser is Success:
                    return (response, error)
                else:
                    return (None, response, error)

            response_data = RESTResponse(response)
            response_data.read(response_body)
            resp = self.response_deserialize(
                response_data=response_data,
                response_types_map=_response_types_map,
            )
            return (resp.data, resp, None)

    @validate_call
    async def get_application_user_with_http_info(
        self,
        app_id: Annotated[StrictStr, Field(description="ID of the Application")],
        user_id: StrictStr,
        expand: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppUser:
        """Retrieve an assigned User

        Retrieves a specific user assignment for app by `id`

        :param app_id: ID of the Application (required)
        :type app_id: str
        :param user_id: (required)
        :type user_id: str
        :param expand:
        :type expand: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "AppUser",
            "403": "Error",
            "404": "Error",
            "429": "Error",
        }

        method, url, header_params, body, post_params = (
            self._get_application_user_serialize(
                app_id=app_id,
                user_id=user_id,
                expand=expand,
                _request_auth=_request_auth,
                _content_type=_content_type,
                _headers=_headers,
                _host_index=_host_index,
            )
        )

        form = {}
        keep_empty_params = False

        request, error = await self._request_executor.create_request(
            method, url, body, header_params, form, keep_empty_params=keep_empty_params
        )

        if error:
            if AppUser is Success:
                return (None, error)
            else:
                return (None, None, error)

        if AppUser is Success:
            response, response_body, error = await self._request_executor.execute(
                request
            )
        else:
            response, response_body, error = await self._request_executor.execute(
                request, AppUser
            )

        if response_body == "" or response.status == 204:
            response_data = RESTResponse(response)
            resp = ApiResponse(
                status_code=response_data.status,
                data=None,
                headers=response_data.getheaders(),
                raw_data=b"",
            )
            return (None, resp, None)
        else:
            response_body = response_body.encode("utf-8")

            if error:
                if AppUser is Success:
                    return (response, error)
                else:
                    return (None, response, error)

            response_data = RESTResponse(response)
            response_data.read(response_body)
            resp = self.response_deserialize(
                response_data=response_data,
                response_types_map=_response_types_map,
            )
            return (resp.data, resp, None)

    @validate_call
    async def get_application_user_without_preload_content(
        self,
        app_id: Annotated[StrictStr, Field(description="ID of the Application")],
        user_id: StrictStr,
        expand: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppUser:
        """Retrieve an assigned User

        Retrieves a specific user assignment for app by `id`

        :param app_id: ID of the Application (required)
        :type app_id: str
        :param user_id: (required)
        :type user_id: str
        :param expand:
        :type expand: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "AppUser",
            "403": "Error",
            "404": "Error",
            "429": "Error",
        }

        method, url, header_params, body, post_params = (
            self._get_application_user_serialize(
                app_id=app_id,
                user_id=user_id,
                expand=expand,
                _request_auth=_request_auth,
                _content_type=_content_type,
                _headers=_headers,
                _host_index=_host_index,
            )
        )

        form = {}
        keep_empty_params = False

        request, error = await self._request_executor.create_request(
            method, url, body, header_params, form, keep_empty_params=keep_empty_params
        )

        if error:
            if AppUser is Success:
                return (None, error)
            else:
                return (None, None, error)

        if AppUser is Success:
            response, response_body, error = await self._request_executor.execute(
                request
            )
        else:
            response, response_body, error = await self._request_executor.execute(
                request, AppUser
            )

        if response_body == "" or response.status == 204:
            response_data = RESTResponse(response)
            resp = ApiResponse(
                status_code=response_data.status,
                data=None,
                headers=response_data.getheaders(),
                raw_data=b"",
            )
            return (None, resp, None)
        else:
            response_body = response_body.encode("utf-8")

            if error:
                if AppUser is Success:
                    return (response, error)
                else:
                    return (None, response, error)

            response_data = RESTResponse(response)
            response_data.read(response_body)
            resp = self.response_deserialize(
                response_data=response_data,
                response_types_map=_response_types_map,
            )
            return (resp.data, resp, None)

    def _get_application_user_serialize(
        self,
        app_id,
        user_id,
        expand,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if app_id is not None:
            _path_params["appId"] = app_id
        if user_id is not None:
            _path_params["userId"] = user_id
        # process the query parameters
        if expand is not None:
            _query_params.append(("expand", expand))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.select_header_accept(["application/json"])

        # authentication setting
        _auth_settings: List[str] = ["apiToken", "oauth2"]

        return self.param_serialize(
            method="GET",
            resource_path="/api/v1/apps/{appId}/users/{userId}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def list_application_users(
        self,
        app_id: Annotated[StrictStr, Field(description="ID of the Application")],
        q: Optional[StrictStr] = None,
        query_scope: Optional[StrictStr] = None,
        after: Annotated[
            Optional[StrictStr],
            Field(
                description="specifies the pagination cursor for the next page of assignments"
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(description="specifies the number of results for a page"),
        ] = None,
        filter: Optional[StrictStr] = None,
        expand: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[AppUser]:
        """List all assigned Users

        Lists all assigned users for an app

        :param app_id: ID of the Application (required)
        :type app_id: str
        :param q:
        :type q: str
        :param query_scope:
        :type query_scope: str
        :param after: specifies the pagination cursor for the next page of assignments
        :type after: str
        :param limit: specifies the number of results for a page
        :type limit: int
        :param filter:
        :type filter: str
        :param expand:
        :type expand: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "List[AppUser]",
            "403": "Error",
            "404": "Error",
            "429": "Error",
        }

        method, url, header_params, body, post_params = (
            self._list_application_users_serialize(
                app_id=app_id,
                q=q,
                query_scope=query_scope,
                after=after,
                limit=limit,
                filter=filter,
                expand=expand,
                _request_auth=_request_auth,
                _content_type=_content_type,
                _headers=_headers,
                _host_index=_host_index,
            )
        )

        form = {}
        keep_empty_params = False

        request, error = await self._request_executor.create_request(
            method, url, body, header_params, form, keep_empty_params=keep_empty_params
        )

        if error:
            if List[AppUser] is Success:
                return (None, error)
            else:
                return (None, None, error)

        if List[AppUser] is Success:
            response, response_body, error = await self._request_executor.execute(
                request
            )
        else:
            response, response_body, error = await self._request_executor.execute(
                request, AppUser
            )

        if response_body == "" or response.status == 204:
            response_data = RESTResponse(response)
            resp = ApiResponse(
                status_code=response_data.status,
                data=None,
                headers=response_data.getheaders(),
                raw_data=b"",
            )
            return (None, resp, None)
        else:
            response_body = response_body.encode("utf-8")

            if error:
                if List[AppUser] is Success:
                    return (response, error)
                else:
                    return (None, response, error)

            response_data = RESTResponse(response)
            response_data.read(response_body)
            resp = self.response_deserialize(
                response_data=response_data,
                response_types_map=_response_types_map,
            )
            return (resp.data, resp, None)

    @validate_call
    async def list_application_users_with_http_info(
        self,
        app_id: Annotated[StrictStr, Field(description="ID of the Application")],
        q: Optional[StrictStr] = None,
        query_scope: Optional[StrictStr] = None,
        after: Annotated[
            Optional[StrictStr],
            Field(
                description="specifies the pagination cursor for the next page of assignments"
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(description="specifies the number of results for a page"),
        ] = None,
        filter: Optional[StrictStr] = None,
        expand: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[AppUser]:
        """List all assigned Users

        Lists all assigned users for an app

        :param app_id: ID of the Application (required)
        :type app_id: str
        :param q:
        :type q: str
        :param query_scope:
        :type query_scope: str
        :param after: specifies the pagination cursor for the next page of assignments
        :type after: str
        :param limit: specifies the number of results for a page
        :type limit: int
        :param filter:
        :type filter: str
        :param expand:
        :type expand: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "List[AppUser]",
            "403": "Error",
            "404": "Error",
            "429": "Error",
        }

        method, url, header_params, body, post_params = (
            self._list_application_users_serialize(
                app_id=app_id,
                q=q,
                query_scope=query_scope,
                after=after,
                limit=limit,
                filter=filter,
                expand=expand,
                _request_auth=_request_auth,
                _content_type=_content_type,
                _headers=_headers,
                _host_index=_host_index,
            )
        )

        form = {}
        keep_empty_params = False

        request, error = await self._request_executor.create_request(
            method, url, body, header_params, form, keep_empty_params=keep_empty_params
        )

        if error:
            if List[AppUser] is Success:
                return (None, error)
            else:
                return (None, None, error)

        if List[AppUser] is Success:
            response, response_body, error = await self._request_executor.execute(
                request
            )
        else:
            response, response_body, error = await self._request_executor.execute(
                request, AppUser
            )

        if response_body == "" or response.status == 204:
            response_data = RESTResponse(response)
            resp = ApiResponse(
                status_code=response_data.status,
                data=None,
                headers=response_data.getheaders(),
                raw_data=b"",
            )
            return (None, resp, None)
        else:
            response_body = response_body.encode("utf-8")

            if error:
                if List[AppUser] is Success:
                    return (response, error)
                else:
                    return (None, response, error)

            response_data = RESTResponse(response)
            response_data.read(response_body)
            resp = self.response_deserialize(
                response_data=response_data,
                response_types_map=_response_types_map,
            )
            return (resp.data, resp, None)

    @validate_call
    async def list_application_users_without_preload_content(
        self,
        app_id: Annotated[StrictStr, Field(description="ID of the Application")],
        q: Optional[StrictStr] = None,
        query_scope: Optional[StrictStr] = None,
        after: Annotated[
            Optional[StrictStr],
            Field(
                description="specifies the pagination cursor for the next page of assignments"
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(description="specifies the number of results for a page"),
        ] = None,
        filter: Optional[StrictStr] = None,
        expand: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[AppUser]:
        """List all assigned Users

        Lists all assigned users for an app

        :param app_id: ID of the Application (required)
        :type app_id: str
        :param q:
        :type q: str
        :param query_scope:
        :type query_scope: str
        :param after: specifies the pagination cursor for the next page of assignments
        :type after: str
        :param limit: specifies the number of results for a page
        :type limit: int
        :param filter:
        :type filter: str
        :param expand:
        :type expand: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "List[AppUser]",
            "403": "Error",
            "404": "Error",
            "429": "Error",
        }

        method, url, header_params, body, post_params = (
            self._list_application_users_serialize(
                app_id=app_id,
                q=q,
                query_scope=query_scope,
                after=after,
                limit=limit,
                filter=filter,
                expand=expand,
                _request_auth=_request_auth,
                _content_type=_content_type,
                _headers=_headers,
                _host_index=_host_index,
            )
        )

        form = {}
        keep_empty_params = False

        request, error = await self._request_executor.create_request(
            method, url, body, header_params, form, keep_empty_params=keep_empty_params
        )

        if error:
            if List[AppUser] is Success:
                return (None, error)
            else:
                return (None, None, error)

        if List[AppUser] is Success:
            response, response_body, error = await self._request_executor.execute(
                request
            )
        else:
            response, response_body, error = await self._request_executor.execute(
                request, AppUser
            )

        if response_body == "" or response.status == 204:
            response_data = RESTResponse(response)
            resp = ApiResponse(
                status_code=response_data.status,
                data=None,
                headers=response_data.getheaders(),
                raw_data=b"",
            )
            return (None, resp, None)
        else:
            response_body = response_body.encode("utf-8")

            if error:
                if List[AppUser] is Success:
                    return (response, error)
                else:
                    return (None, response, error)

            response_data = RESTResponse(response)
            response_data.read(response_body)
            resp = self.response_deserialize(
                response_data=response_data,
                response_types_map=_response_types_map,
            )
            return (resp.data, resp, None)

    def _list_application_users_serialize(
        self,
        app_id,
        q,
        query_scope,
        after,
        limit,
        filter,
        expand,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if app_id is not None:
            _path_params["appId"] = app_id
        # process the query parameters
        if q is not None:
            _query_params.append(("q", q))

        if query_scope is not None:
            _query_params.append(("query_scope", query_scope))

        if after is not None:
            _query_params.append(("after", after))

        if limit is not None:
            _query_params.append(("limit", limit))

        if filter is not None:
            _query_params.append(("filter", filter))

        if expand is not None:
            _query_params.append(("expand", expand))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.select_header_accept(["application/json"])

        # authentication setting
        _auth_settings: List[str] = ["apiToken", "oauth2"]

        return self.param_serialize(
            method="GET",
            resource_path="/api/v1/apps/{appId}/users",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def unassign_user_from_application(
        self,
        app_id: Annotated[StrictStr, Field(description="ID of the Application")],
        user_id: StrictStr,
        send_email: Optional[StrictBool] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Unassign an App User

        Unassigns a user from an application

        :param app_id: ID of the Application (required)
        :type app_id: str
        :param user_id: (required)
        :type user_id: str
        :param send_email:
        :type send_email: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            "204": None,
            "403": "Error",
            "404": "Error",
            "429": "Error",
        }

        method, url, header_params, body, post_params = (
            self._unassign_user_from_application_serialize(
                app_id=app_id,
                user_id=user_id,
                send_email=send_email,
                _request_auth=_request_auth,
                _content_type=_content_type,
                _headers=_headers,
                _host_index=_host_index,
            )
        )

        form = {}
        keep_empty_params = False

        request, error = await self._request_executor.create_request(
            method, url, body, header_params, form, keep_empty_params=keep_empty_params
        )

        if error:
            return (None, error)

        response, response_body, error = await self._request_executor.execute(request)

        if response_body == "" or response.status == 204:
            response_data = RESTResponse(response)
            resp = ApiResponse(
                status_code=response_data.status,
                data=None,
                headers=response_data.getheaders(),
                raw_data=b"",
            )
            return (None, resp, None)
        else:
            response_body = response_body.encode("utf-8")

            if error:
                return (response, error)

            response_data = RESTResponse(response)
            response_data.read(response_body)
            resp = self.response_deserialize(
                response_data=response_data,
                response_types_map=_response_types_map,
            )
            return (resp.data, resp, None)

    @validate_call
    async def unassign_user_from_application_with_http_info(
        self,
        app_id: Annotated[StrictStr, Field(description="ID of the Application")],
        user_id: StrictStr,
        send_email: Optional[StrictBool] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Unassign an App User

        Unassigns a user from an application

        :param app_id: ID of the Application (required)
        :type app_id: str
        :param user_id: (required)
        :type user_id: str
        :param send_email:
        :type send_email: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            "204": None,
            "403": "Error",
            "404": "Error",
            "429": "Error",
        }

        method, url, header_params, body, post_params = (
            self._unassign_user_from_application_serialize(
                app_id=app_id,
                user_id=user_id,
                send_email=send_email,
                _request_auth=_request_auth,
                _content_type=_content_type,
                _headers=_headers,
                _host_index=_host_index,
            )
        )

        form = {}
        keep_empty_params = False

        request, error = await self._request_executor.create_request(
            method, url, body, header_params, form, keep_empty_params=keep_empty_params
        )

        if error:
            return (None, error)

        response, response_body, error = await self._request_executor.execute(request)

        if response_body == "" or response.status == 204:
            response_data = RESTResponse(response)
            resp = ApiResponse(
                status_code=response_data.status,
                data=None,
                headers=response_data.getheaders(),
                raw_data=b"",
            )
            return (None, resp, None)
        else:
            response_body = response_body.encode("utf-8")

            if error:
                return (response, error)

            response_data = RESTResponse(response)
            response_data.read(response_body)
            resp = self.response_deserialize(
                response_data=response_data,
                response_types_map=_response_types_map,
            )
            return (resp.data, resp, None)

    @validate_call
    async def unassign_user_from_application_without_preload_content(
        self,
        app_id: Annotated[StrictStr, Field(description="ID of the Application")],
        user_id: StrictStr,
        send_email: Optional[StrictBool] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Unassign an App User

        Unassigns a user from an application

        :param app_id: ID of the Application (required)
        :type app_id: str
        :param user_id: (required)
        :type user_id: str
        :param send_email:
        :type send_email: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            "204": None,
            "403": "Error",
            "404": "Error",
            "429": "Error",
        }

        method, url, header_params, body, post_params = (
            self._unassign_user_from_application_serialize(
                app_id=app_id,
                user_id=user_id,
                send_email=send_email,
                _request_auth=_request_auth,
                _content_type=_content_type,
                _headers=_headers,
                _host_index=_host_index,
            )
        )

        form = {}
        keep_empty_params = False

        request, error = await self._request_executor.create_request(
            method, url, body, header_params, form, keep_empty_params=keep_empty_params
        )

        if error:
            return (None, error)

        response, response_body, error = await self._request_executor.execute(request)

        if response_body == "" or response.status == 204:
            response_data = RESTResponse(response)
            resp = ApiResponse(
                status_code=response_data.status,
                data=None,
                headers=response_data.getheaders(),
                raw_data=b"",
            )
            return (None, resp, None)
        else:
            response_body = response_body.encode("utf-8")

            if error:
                return (response, error)

            response_data = RESTResponse(response)
            response_data.read(response_body)
            resp = self.response_deserialize(
                response_data=response_data,
                response_types_map=_response_types_map,
            )
            return (resp.data, resp, None)

    def _unassign_user_from_application_serialize(
        self,
        app_id,
        user_id,
        send_email,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if app_id is not None:
            _path_params["appId"] = app_id
        if user_id is not None:
            _path_params["userId"] = user_id
        # process the query parameters
        if send_email is not None:
            _query_params.append(("sendEmail", send_email))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.select_header_accept(["application/json"])

        # authentication setting
        _auth_settings: List[str] = ["apiToken", "oauth2"]

        return self.param_serialize(
            method="DELETE",
            resource_path="/api/v1/apps/{appId}/users/{userId}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def update_application_user(
        self,
        app_id: Annotated[StrictStr, Field(description="ID of the Application")],
        user_id: StrictStr,
        app_user: AppUser,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppUser:
        """Update an App Profile for an assigned User

        Updates a user's profile for an application

        :param app_id: ID of the Application (required)
        :type app_id: str
        :param user_id: (required)
        :type user_id: str
        :param app_user: (required)
        :type app_user: AppUser
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "AppUser",
            "400": "Error",
            "403": "Error",
            "404": "Error",
            "429": "Error",
        }

        method, url, header_params, body, post_params = (
            self._update_application_user_serialize(
                app_id=app_id,
                user_id=user_id,
                app_user=app_user,
                _request_auth=_request_auth,
                _content_type=_content_type,
                _headers=_headers,
                _host_index=_host_index,
            )
        )

        form = {}
        keep_empty_params = False

        request, error = await self._request_executor.create_request(
            method, url, body, header_params, form, keep_empty_params=keep_empty_params
        )

        if error:
            if AppUser is Success:
                return (None, error)
            else:
                return (None, None, error)

        if AppUser is Success:
            response, response_body, error = await self._request_executor.execute(
                request
            )
        else:
            response, response_body, error = await self._request_executor.execute(
                request, AppUser
            )

        if response_body == "" or response.status == 204:
            response_data = RESTResponse(response)
            resp = ApiResponse(
                status_code=response_data.status,
                data=None,
                headers=response_data.getheaders(),
                raw_data=b"",
            )
            return (None, resp, None)
        else:
            response_body = response_body.encode("utf-8")

            if error:
                if AppUser is Success:
                    return (response, error)
                else:
                    return (None, response, error)

            response_data = RESTResponse(response)
            response_data.read(response_body)
            resp = self.response_deserialize(
                response_data=response_data,
                response_types_map=_response_types_map,
            )
            return (resp.data, resp, None)

    @validate_call
    async def update_application_user_with_http_info(
        self,
        app_id: Annotated[StrictStr, Field(description="ID of the Application")],
        user_id: StrictStr,
        app_user: AppUser,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppUser:
        """Update an App Profile for an assigned User

        Updates a user's profile for an application

        :param app_id: ID of the Application (required)
        :type app_id: str
        :param user_id: (required)
        :type user_id: str
        :param app_user: (required)
        :type app_user: AppUser
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "AppUser",
            "400": "Error",
            "403": "Error",
            "404": "Error",
            "429": "Error",
        }

        method, url, header_params, body, post_params = (
            self._update_application_user_serialize(
                app_id=app_id,
                user_id=user_id,
                app_user=app_user,
                _request_auth=_request_auth,
                _content_type=_content_type,
                _headers=_headers,
                _host_index=_host_index,
            )
        )

        form = {}
        keep_empty_params = False

        request, error = await self._request_executor.create_request(
            method, url, body, header_params, form, keep_empty_params=keep_empty_params
        )

        if error:
            if AppUser is Success:
                return (None, error)
            else:
                return (None, None, error)

        if AppUser is Success:
            response, response_body, error = await self._request_executor.execute(
                request
            )
        else:
            response, response_body, error = await self._request_executor.execute(
                request, AppUser
            )

        if response_body == "" or response.status == 204:
            response_data = RESTResponse(response)
            resp = ApiResponse(
                status_code=response_data.status,
                data=None,
                headers=response_data.getheaders(),
                raw_data=b"",
            )
            return (None, resp, None)
        else:
            response_body = response_body.encode("utf-8")

            if error:
                if AppUser is Success:
                    return (response, error)
                else:
                    return (None, response, error)

            response_data = RESTResponse(response)
            response_data.read(response_body)
            resp = self.response_deserialize(
                response_data=response_data,
                response_types_map=_response_types_map,
            )
            return (resp.data, resp, None)

    @validate_call
    async def update_application_user_without_preload_content(
        self,
        app_id: Annotated[StrictStr, Field(description="ID of the Application")],
        user_id: StrictStr,
        app_user: AppUser,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AppUser:
        """Update an App Profile for an assigned User

        Updates a user's profile for an application

        :param app_id: ID of the Application (required)
        :type app_id: str
        :param user_id: (required)
        :type user_id: str
        :param app_user: (required)
        :type app_user: AppUser
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "AppUser",
            "400": "Error",
            "403": "Error",
            "404": "Error",
            "429": "Error",
        }

        method, url, header_params, body, post_params = (
            self._update_application_user_serialize(
                app_id=app_id,
                user_id=user_id,
                app_user=app_user,
                _request_auth=_request_auth,
                _content_type=_content_type,
                _headers=_headers,
                _host_index=_host_index,
            )
        )

        form = {}
        keep_empty_params = False

        request, error = await self._request_executor.create_request(
            method, url, body, header_params, form, keep_empty_params=keep_empty_params
        )

        if error:
            if AppUser is Success:
                return (None, error)
            else:
                return (None, None, error)

        if AppUser is Success:
            response, response_body, error = await self._request_executor.execute(
                request
            )
        else:
            response, response_body, error = await self._request_executor.execute(
                request, AppUser
            )

        if response_body == "" or response.status == 204:
            response_data = RESTResponse(response)
            resp = ApiResponse(
                status_code=response_data.status,
                data=None,
                headers=response_data.getheaders(),
                raw_data=b"",
            )
            return (None, resp, None)
        else:
            response_body = response_body.encode("utf-8")

            if error:
                if AppUser is Success:
                    return (response, error)
                else:
                    return (None, response, error)

            response_data = RESTResponse(response)
            response_data.read(response_body)
            resp = self.response_deserialize(
                response_data=response_data,
                response_types_map=_response_types_map,
            )
            return (resp.data, resp, None)

    def _update_application_user_serialize(
        self,
        app_id,
        user_id,
        app_user,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if app_id is not None:
            _path_params["appId"] = app_id
        if user_id is not None:
            _path_params["userId"] = user_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if app_user is not None:
            _body_params = app_user

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.select_header_accept(["application/json"])

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.select_header_content_type(
                ["application/json"]
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ["apiToken", "oauth2"]

        return self.param_serialize(
            method="POST",
            resource_path="/api/v1/apps/{appId}/users/{userId}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )
