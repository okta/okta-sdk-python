# The Okta software accompanied by this notice is provided pursuant to the following terms:
# Copyright Â© 2025-Present, Okta, Inc.
# Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
# License.
# You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
# Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and limitations under the License.
# coding: utf-8

"""
Okta Admin Management

Allows customers to easily access the Okta Management APIs

The version of the OpenAPI document: 5.1.0
Contact: devex-public@okta.com
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""  # noqa: E501

from typing import Any, Dict, Tuple, Union
from typing import List, Optional

from pydantic import Field, StrictInt, StrictStr
from pydantic import validate_call, StrictFloat
from typing_extensions import Annotated

from okta.api_client import ApiClient, RequestSerialized
from okta.api_response import ApiResponse
from okta.models.application_group_assignment import ApplicationGroupAssignment
from okta.models.success import Success
from okta.rest import RESTResponse


class ApplicationGroupsApi(ApiClient):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, configuration) -> None:
        super().__init__(configuration=configuration)

    @validate_call
    async def assign_group_to_application(
        self,
        app_id: Annotated[StrictStr, Field(description="ID of the Application")],
        group_id: Annotated[StrictStr, Field(description="The `id` of the group")],
        application_group_assignment: Optional[ApplicationGroupAssignment] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApplicationGroupAssignment:
        """Assign a Group

        Assigns a group to an application

        :param app_id: ID of the Application (required)
        :type app_id: str
        :param group_id: The `id` of the group (required)
        :type group_id: str
        :param application_group_assignment:
        :type application_group_assignment: ApplicationGroupAssignment
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ApplicationGroupAssignment",
            "400": "Error",
            "403": "Error",
            "404": "Error",
            "429": "Error",
        }

        method, url, header_params, body, post_params = (
            self._assign_group_to_application_serialize(
                app_id=app_id,
                group_id=group_id,
                application_group_assignment=application_group_assignment,
                _request_auth=_request_auth,
                _content_type=_content_type,
                _headers=_headers,
                _host_index=_host_index,
            )
        )

        form = {}
        keep_empty_params = False

        request, error = await self._request_executor.create_request(
            method, url, body, header_params, form, keep_empty_params=keep_empty_params
        )

        if error:
            if ApplicationGroupAssignment is Success:
                return (None, error)
            else:
                return (None, None, error)

        if ApplicationGroupAssignment is Success:
            response, response_body, error = await self._request_executor.execute(
                request
            )
        else:
            response, response_body, error = await self._request_executor.execute(
                request, ApplicationGroupAssignment
            )

        if response_body == "" or response.status == 204:
            response_data = RESTResponse(response)
            resp = ApiResponse(
                status_code=response_data.status,
                data=None,
                headers=response_data.getheaders(),
                raw_data=b"",
            )
            return (None, resp, None)
        else:
            response_body = response_body.encode("utf-8")

            if error:
                if ApplicationGroupAssignment is Success:
                    return (response, error)
                else:
                    return (None, response, error)

            response_data = RESTResponse(response)
            response_data.read(response_body)
            resp = self.response_deserialize(
                response_data=response_data,
                response_types_map=_response_types_map,
            )
            return (resp.data, resp, None)

    @validate_call
    async def assign_group_to_application_with_http_info(
        self,
        app_id: Annotated[StrictStr, Field(description="ID of the Application")],
        group_id: Annotated[StrictStr, Field(description="The `id` of the group")],
        application_group_assignment: Optional[ApplicationGroupAssignment] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApplicationGroupAssignment:
        """Assign a Group

        Assigns a group to an application

        :param app_id: ID of the Application (required)
        :type app_id: str
        :param group_id: The `id` of the group (required)
        :type group_id: str
        :param application_group_assignment:
        :type application_group_assignment: ApplicationGroupAssignment
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ApplicationGroupAssignment",
            "400": "Error",
            "403": "Error",
            "404": "Error",
            "429": "Error",
        }

        method, url, header_params, body, post_params = (
            self._assign_group_to_application_serialize(
                app_id=app_id,
                group_id=group_id,
                application_group_assignment=application_group_assignment,
                _request_auth=_request_auth,
                _content_type=_content_type,
                _headers=_headers,
                _host_index=_host_index,
            )
        )

        form = {}
        keep_empty_params = False

        request, error = await self._request_executor.create_request(
            method, url, body, header_params, form, keep_empty_params=keep_empty_params
        )

        if error:
            if ApplicationGroupAssignment is Success:
                return (None, error)
            else:
                return (None, None, error)

        if ApplicationGroupAssignment is Success:
            response, response_body, error = await self._request_executor.execute(
                request
            )
        else:
            response, response_body, error = await self._request_executor.execute(
                request, ApplicationGroupAssignment
            )

        if response_body == "" or response.status == 204:
            response_data = RESTResponse(response)
            resp = ApiResponse(
                status_code=response_data.status,
                data=None,
                headers=response_data.getheaders(),
                raw_data=b"",
            )
            return (None, resp, None)
        else:
            response_body = response_body.encode("utf-8")

            if error:
                if ApplicationGroupAssignment is Success:
                    return (response, error)
                else:
                    return (None, response, error)

            response_data = RESTResponse(response)
            response_data.read(response_body)
            resp = self.response_deserialize(
                response_data=response_data,
                response_types_map=_response_types_map,
            )
            return (resp.data, resp, None)

    @validate_call
    async def assign_group_to_application_without_preload_content(
        self,
        app_id: Annotated[StrictStr, Field(description="ID of the Application")],
        group_id: Annotated[StrictStr, Field(description="The `id` of the group")],
        application_group_assignment: Optional[ApplicationGroupAssignment] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApplicationGroupAssignment:
        """Assign a Group

        Assigns a group to an application

        :param app_id: ID of the Application (required)
        :type app_id: str
        :param group_id: The `id` of the group (required)
        :type group_id: str
        :param application_group_assignment:
        :type application_group_assignment: ApplicationGroupAssignment
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ApplicationGroupAssignment",
            "400": "Error",
            "403": "Error",
            "404": "Error",
            "429": "Error",
        }

        method, url, header_params, body, post_params = (
            self._assign_group_to_application_serialize(
                app_id=app_id,
                group_id=group_id,
                application_group_assignment=application_group_assignment,
                _request_auth=_request_auth,
                _content_type=_content_type,
                _headers=_headers,
                _host_index=_host_index,
            )
        )

        form = {}
        keep_empty_params = False

        request, error = await self._request_executor.create_request(
            method, url, body, header_params, form, keep_empty_params=keep_empty_params
        )

        if error:
            if ApplicationGroupAssignment is Success:
                return (None, error)
            else:
                return (None, None, error)

        if ApplicationGroupAssignment is Success:
            response, response_body, error = await self._request_executor.execute(
                request
            )
        else:
            response, response_body, error = await self._request_executor.execute(
                request, ApplicationGroupAssignment
            )

        if response_body == "" or response.status == 204:
            response_data = RESTResponse(response)
            resp = ApiResponse(
                status_code=response_data.status,
                data=None,
                headers=response_data.getheaders(),
                raw_data=b"",
            )
            return (None, resp, None)
        else:
            response_body = response_body.encode("utf-8")

            if error:
                if ApplicationGroupAssignment is Success:
                    return (response, error)
                else:
                    return (None, response, error)

            response_data = RESTResponse(response)
            response_data.read(response_body)
            resp = self.response_deserialize(
                response_data=response_data,
                response_types_map=_response_types_map,
            )
            return (resp.data, resp, None)

    def _assign_group_to_application_serialize(
        self,
        app_id,
        group_id,
        application_group_assignment,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if app_id is not None:
            _path_params["appId"] = app_id
        if group_id is not None:
            _path_params["groupId"] = group_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if application_group_assignment is not None:
            _body_params = application_group_assignment

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.select_header_accept(["application/json"])

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.select_header_content_type(
                ["application/json"]
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = ["apiToken", "oauth2"]

        return self.param_serialize(
            method="PUT",
            resource_path="/api/v1/apps/{appId}/groups/{groupId}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def get_application_group_assignment(
        self,
        app_id: Annotated[StrictStr, Field(description="ID of the Application")],
        group_id: Annotated[StrictStr, Field(description="The `id` of the group")],
        expand: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApplicationGroupAssignment:
        """Retrieve an Assigned Group

        Retrieves an application group assignment

        :param app_id: ID of the Application (required)
        :type app_id: str
        :param group_id: The `id` of the group (required)
        :type group_id: str
        :param expand:
        :type expand: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ApplicationGroupAssignment",
            "403": "Error",
            "404": "Error",
            "429": "Error",
        }

        method, url, header_params, body, post_params = (
            self._get_application_group_assignment_serialize(
                app_id=app_id,
                group_id=group_id,
                expand=expand,
                _request_auth=_request_auth,
                _content_type=_content_type,
                _headers=_headers,
                _host_index=_host_index,
            )
        )

        form = {}
        keep_empty_params = False

        request, error = await self._request_executor.create_request(
            method, url, body, header_params, form, keep_empty_params=keep_empty_params
        )

        if error:
            if ApplicationGroupAssignment is Success:
                return (None, error)
            else:
                return (None, None, error)

        if ApplicationGroupAssignment is Success:
            response, response_body, error = await self._request_executor.execute(
                request
            )
        else:
            response, response_body, error = await self._request_executor.execute(
                request, ApplicationGroupAssignment
            )

        if response_body == "" or response.status == 204:
            response_data = RESTResponse(response)
            resp = ApiResponse(
                status_code=response_data.status,
                data=None,
                headers=response_data.getheaders(),
                raw_data=b"",
            )
            return (None, resp, None)
        else:
            response_body = response_body.encode("utf-8")

            if error:
                if ApplicationGroupAssignment is Success:
                    return (response, error)
                else:
                    return (None, response, error)

            response_data = RESTResponse(response)
            response_data.read(response_body)
            resp = self.response_deserialize(
                response_data=response_data,
                response_types_map=_response_types_map,
            )
            return (resp.data, resp, None)

    @validate_call
    async def get_application_group_assignment_with_http_info(
        self,
        app_id: Annotated[StrictStr, Field(description="ID of the Application")],
        group_id: Annotated[StrictStr, Field(description="The `id` of the group")],
        expand: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApplicationGroupAssignment:
        """Retrieve an Assigned Group

        Retrieves an application group assignment

        :param app_id: ID of the Application (required)
        :type app_id: str
        :param group_id: The `id` of the group (required)
        :type group_id: str
        :param expand:
        :type expand: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ApplicationGroupAssignment",
            "403": "Error",
            "404": "Error",
            "429": "Error",
        }

        method, url, header_params, body, post_params = (
            self._get_application_group_assignment_serialize(
                app_id=app_id,
                group_id=group_id,
                expand=expand,
                _request_auth=_request_auth,
                _content_type=_content_type,
                _headers=_headers,
                _host_index=_host_index,
            )
        )

        form = {}
        keep_empty_params = False

        request, error = await self._request_executor.create_request(
            method, url, body, header_params, form, keep_empty_params=keep_empty_params
        )

        if error:
            if ApplicationGroupAssignment is Success:
                return (None, error)
            else:
                return (None, None, error)

        if ApplicationGroupAssignment is Success:
            response, response_body, error = await self._request_executor.execute(
                request
            )
        else:
            response, response_body, error = await self._request_executor.execute(
                request, ApplicationGroupAssignment
            )

        if response_body == "" or response.status == 204:
            response_data = RESTResponse(response)
            resp = ApiResponse(
                status_code=response_data.status,
                data=None,
                headers=response_data.getheaders(),
                raw_data=b"",
            )
            return (None, resp, None)
        else:
            response_body = response_body.encode("utf-8")

            if error:
                if ApplicationGroupAssignment is Success:
                    return (response, error)
                else:
                    return (None, response, error)

            response_data = RESTResponse(response)
            response_data.read(response_body)
            resp = self.response_deserialize(
                response_data=response_data,
                response_types_map=_response_types_map,
            )
            return (resp.data, resp, None)

    @validate_call
    async def get_application_group_assignment_without_preload_content(
        self,
        app_id: Annotated[StrictStr, Field(description="ID of the Application")],
        group_id: Annotated[StrictStr, Field(description="The `id` of the group")],
        expand: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApplicationGroupAssignment:
        """Retrieve an Assigned Group

        Retrieves an application group assignment

        :param app_id: ID of the Application (required)
        :type app_id: str
        :param group_id: The `id` of the group (required)
        :type group_id: str
        :param expand:
        :type expand: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ApplicationGroupAssignment",
            "403": "Error",
            "404": "Error",
            "429": "Error",
        }

        method, url, header_params, body, post_params = (
            self._get_application_group_assignment_serialize(
                app_id=app_id,
                group_id=group_id,
                expand=expand,
                _request_auth=_request_auth,
                _content_type=_content_type,
                _headers=_headers,
                _host_index=_host_index,
            )
        )

        form = {}
        keep_empty_params = False

        request, error = await self._request_executor.create_request(
            method, url, body, header_params, form, keep_empty_params=keep_empty_params
        )

        if error:
            if ApplicationGroupAssignment is Success:
                return (None, error)
            else:
                return (None, None, error)

        if ApplicationGroupAssignment is Success:
            response, response_body, error = await self._request_executor.execute(
                request
            )
        else:
            response, response_body, error = await self._request_executor.execute(
                request, ApplicationGroupAssignment
            )

        if response_body == "" or response.status == 204:
            response_data = RESTResponse(response)
            resp = ApiResponse(
                status_code=response_data.status,
                data=None,
                headers=response_data.getheaders(),
                raw_data=b"",
            )
            return (None, resp, None)
        else:
            response_body = response_body.encode("utf-8")

            if error:
                if ApplicationGroupAssignment is Success:
                    return (response, error)
                else:
                    return (None, response, error)

            response_data = RESTResponse(response)
            response_data.read(response_body)
            resp = self.response_deserialize(
                response_data=response_data,
                response_types_map=_response_types_map,
            )
            return (resp.data, resp, None)

    def _get_application_group_assignment_serialize(
        self,
        app_id,
        group_id,
        expand,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if app_id is not None:
            _path_params["appId"] = app_id
        if group_id is not None:
            _path_params["groupId"] = group_id
        # process the query parameters
        if expand is not None:
            _query_params.append(("expand", expand))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.select_header_accept(["application/json"])

        # authentication setting
        _auth_settings: List[str] = ["apiToken", "oauth2"]

        return self.param_serialize(
            method="GET",
            resource_path="/api/v1/apps/{appId}/groups/{groupId}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def list_application_group_assignments(
        self,
        app_id: Annotated[StrictStr, Field(description="ID of the Application")],
        q: Optional[StrictStr] = None,
        after: Annotated[
            Optional[StrictStr],
            Field(
                description="Specifies the pagination cursor for the next page of assignments"
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(description="Specifies the number of results for a page"),
        ] = None,
        expand: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ApplicationGroupAssignment]:
        """List all Assigned Groups

        Lists all group assignments for an application

        :param app_id: ID of the Application (required)
        :type app_id: str
        :param q:
        :type q: str
        :param after: Specifies the pagination cursor for the next page of assignments
        :type after: str
        :param limit: Specifies the number of results for a page
        :type limit: int
        :param expand:
        :type expand: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "List[ApplicationGroupAssignment]",
            "403": "Error",
            "404": "Error",
            "429": "Error",
        }

        method, url, header_params, body, post_params = (
            self._list_application_group_assignments_serialize(
                app_id=app_id,
                q=q,
                after=after,
                limit=limit,
                expand=expand,
                _request_auth=_request_auth,
                _content_type=_content_type,
                _headers=_headers,
                _host_index=_host_index,
            )
        )

        form = {}
        keep_empty_params = False

        request, error = await self._request_executor.create_request(
            method, url, body, header_params, form, keep_empty_params=keep_empty_params
        )

        if error:
            if List[ApplicationGroupAssignment] is Success:
                return (None, error)
            else:
                return (None, None, error)

        if List[ApplicationGroupAssignment] is Success:
            response, response_body, error = await self._request_executor.execute(
                request
            )
        else:
            response, response_body, error = await self._request_executor.execute(
                request, ApplicationGroupAssignment
            )

        if response_body == "" or response.status == 204:
            response_data = RESTResponse(response)
            resp = ApiResponse(
                status_code=response_data.status,
                data=None,
                headers=response_data.getheaders(),
                raw_data=b"",
            )
            return (None, resp, None)
        else:
            response_body = response_body.encode("utf-8")

            if error:
                if List[ApplicationGroupAssignment] is Success:
                    return (response, error)
                else:
                    return (None, response, error)

            response_data = RESTResponse(response)
            response_data.read(response_body)
            resp = self.response_deserialize(
                response_data=response_data,
                response_types_map=_response_types_map,
            )
            return (resp.data, resp, None)

    @validate_call
    async def list_application_group_assignments_with_http_info(
        self,
        app_id: Annotated[StrictStr, Field(description="ID of the Application")],
        q: Optional[StrictStr] = None,
        after: Annotated[
            Optional[StrictStr],
            Field(
                description="Specifies the pagination cursor for the next page of assignments"
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(description="Specifies the number of results for a page"),
        ] = None,
        expand: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ApplicationGroupAssignment]:
        """List all Assigned Groups

        Lists all group assignments for an application

        :param app_id: ID of the Application (required)
        :type app_id: str
        :param q:
        :type q: str
        :param after: Specifies the pagination cursor for the next page of assignments
        :type after: str
        :param limit: Specifies the number of results for a page
        :type limit: int
        :param expand:
        :type expand: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "List[ApplicationGroupAssignment]",
            "403": "Error",
            "404": "Error",
            "429": "Error",
        }

        method, url, header_params, body, post_params = (
            self._list_application_group_assignments_serialize(
                app_id=app_id,
                q=q,
                after=after,
                limit=limit,
                expand=expand,
                _request_auth=_request_auth,
                _content_type=_content_type,
                _headers=_headers,
                _host_index=_host_index,
            )
        )

        form = {}
        keep_empty_params = False

        request, error = await self._request_executor.create_request(
            method, url, body, header_params, form, keep_empty_params=keep_empty_params
        )

        if error:
            if List[ApplicationGroupAssignment] is Success:
                return (None, error)
            else:
                return (None, None, error)

        if List[ApplicationGroupAssignment] is Success:
            response, response_body, error = await self._request_executor.execute(
                request
            )
        else:
            response, response_body, error = await self._request_executor.execute(
                request, ApplicationGroupAssignment
            )

        if response_body == "" or response.status == 204:
            response_data = RESTResponse(response)
            resp = ApiResponse(
                status_code=response_data.status,
                data=None,
                headers=response_data.getheaders(),
                raw_data=b"",
            )
            return (None, resp, None)
        else:
            response_body = response_body.encode("utf-8")

            if error:
                if List[ApplicationGroupAssignment] is Success:
                    return (response, error)
                else:
                    return (None, response, error)

            response_data = RESTResponse(response)
            response_data.read(response_body)
            resp = self.response_deserialize(
                response_data=response_data,
                response_types_map=_response_types_map,
            )
            return (resp.data, resp, None)

    @validate_call
    async def list_application_group_assignments_without_preload_content(
        self,
        app_id: Annotated[StrictStr, Field(description="ID of the Application")],
        q: Optional[StrictStr] = None,
        after: Annotated[
            Optional[StrictStr],
            Field(
                description="Specifies the pagination cursor for the next page of assignments"
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(description="Specifies the number of results for a page"),
        ] = None,
        expand: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ApplicationGroupAssignment]:
        """List all Assigned Groups

        Lists all group assignments for an application

        :param app_id: ID of the Application (required)
        :type app_id: str
        :param q:
        :type q: str
        :param after: Specifies the pagination cursor for the next page of assignments
        :type after: str
        :param limit: Specifies the number of results for a page
        :type limit: int
        :param expand:
        :type expand: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "List[ApplicationGroupAssignment]",
            "403": "Error",
            "404": "Error",
            "429": "Error",
        }

        method, url, header_params, body, post_params = (
            self._list_application_group_assignments_serialize(
                app_id=app_id,
                q=q,
                after=after,
                limit=limit,
                expand=expand,
                _request_auth=_request_auth,
                _content_type=_content_type,
                _headers=_headers,
                _host_index=_host_index,
            )
        )

        form = {}
        keep_empty_params = False

        request, error = await self._request_executor.create_request(
            method, url, body, header_params, form, keep_empty_params=keep_empty_params
        )

        if error:
            if List[ApplicationGroupAssignment] is Success:
                return (None, error)
            else:
                return (None, None, error)

        if List[ApplicationGroupAssignment] is Success:
            response, response_body, error = await self._request_executor.execute(
                request
            )
        else:
            response, response_body, error = await self._request_executor.execute(
                request, ApplicationGroupAssignment
            )

        if response_body == "" or response.status == 204:
            response_data = RESTResponse(response)
            resp = ApiResponse(
                status_code=response_data.status,
                data=None,
                headers=response_data.getheaders(),
                raw_data=b"",
            )
            return (None, resp, None)
        else:
            response_body = response_body.encode("utf-8")

            if error:
                if List[ApplicationGroupAssignment] is Success:
                    return (response, error)
                else:
                    return (None, response, error)

            response_data = RESTResponse(response)
            response_data.read(response_body)
            resp = self.response_deserialize(
                response_data=response_data,
                response_types_map=_response_types_map,
            )
            return (resp.data, resp, None)

    def _list_application_group_assignments_serialize(
        self,
        app_id,
        q,
        after,
        limit,
        expand,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if app_id is not None:
            _path_params["appId"] = app_id
        # process the query parameters
        if q is not None:
            _query_params.append(("q", q))

        if after is not None:
            _query_params.append(("after", after))

        if limit is not None:
            _query_params.append(("limit", limit))

        if expand is not None:
            _query_params.append(("expand", expand))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.select_header_accept(["application/json"])

        # authentication setting
        _auth_settings: List[str] = ["apiToken", "oauth2"]

        return self.param_serialize(
            method="GET",
            resource_path="/api/v1/apps/{appId}/groups",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    async def unassign_application_from_group(
        self,
        app_id: Annotated[StrictStr, Field(description="ID of the Application")],
        group_id: Annotated[StrictStr, Field(description="The `id` of the group")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Unassign a Group

        Unassigns a group from an application

        :param app_id: ID of the Application (required)
        :type app_id: str
        :param group_id: The `id` of the group (required)
        :type group_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            "204": None,
            "403": "Error",
            "404": "Error",
            "429": "Error",
        }

        method, url, header_params, body, post_params = (
            self._unassign_application_from_group_serialize(
                app_id=app_id,
                group_id=group_id,
                _request_auth=_request_auth,
                _content_type=_content_type,
                _headers=_headers,
                _host_index=_host_index,
            )
        )

        form = {}
        keep_empty_params = False

        request, error = await self._request_executor.create_request(
            method, url, body, header_params, form, keep_empty_params=keep_empty_params
        )

        if error:
            return (None, error)

        response, response_body, error = await self._request_executor.execute(request)

        if response_body == "" or response.status == 204:
            response_data = RESTResponse(response)
            resp = ApiResponse(
                status_code=response_data.status,
                data=None,
                headers=response_data.getheaders(),
                raw_data=b"",
            )
            return (None, resp, None)
        else:
            response_body = response_body.encode("utf-8")

            if error:
                return (response, error)

            response_data = RESTResponse(response)
            response_data.read(response_body)
            resp = self.response_deserialize(
                response_data=response_data,
                response_types_map=_response_types_map,
            )
            return (resp.data, resp, None)

    @validate_call
    async def unassign_application_from_group_with_http_info(
        self,
        app_id: Annotated[StrictStr, Field(description="ID of the Application")],
        group_id: Annotated[StrictStr, Field(description="The `id` of the group")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Unassign a Group

        Unassigns a group from an application

        :param app_id: ID of the Application (required)
        :type app_id: str
        :param group_id: The `id` of the group (required)
        :type group_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            "204": None,
            "403": "Error",
            "404": "Error",
            "429": "Error",
        }

        method, url, header_params, body, post_params = (
            self._unassign_application_from_group_serialize(
                app_id=app_id,
                group_id=group_id,
                _request_auth=_request_auth,
                _content_type=_content_type,
                _headers=_headers,
                _host_index=_host_index,
            )
        )

        form = {}
        keep_empty_params = False

        request, error = await self._request_executor.create_request(
            method, url, body, header_params, form, keep_empty_params=keep_empty_params
        )

        if error:
            return (None, error)

        response, response_body, error = await self._request_executor.execute(request)

        if response_body == "" or response.status == 204:
            response_data = RESTResponse(response)
            resp = ApiResponse(
                status_code=response_data.status,
                data=None,
                headers=response_data.getheaders(),
                raw_data=b"",
            )
            return (None, resp, None)
        else:
            response_body = response_body.encode("utf-8")

            if error:
                return (response, error)

            response_data = RESTResponse(response)
            response_data.read(response_body)
            resp = self.response_deserialize(
                response_data=response_data,
                response_types_map=_response_types_map,
            )
            return (resp.data, resp, None)

    @validate_call
    async def unassign_application_from_group_without_preload_content(
        self,
        app_id: Annotated[StrictStr, Field(description="ID of the Application")],
        group_id: Annotated[StrictStr, Field(description="The `id` of the group")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Unassign a Group

        Unassigns a group from an application

        :param app_id: ID of the Application (required)
        :type app_id: str
        :param group_id: The `id` of the group (required)
        :type group_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            "204": None,
            "403": "Error",
            "404": "Error",
            "429": "Error",
        }

        method, url, header_params, body, post_params = (
            self._unassign_application_from_group_serialize(
                app_id=app_id,
                group_id=group_id,
                _request_auth=_request_auth,
                _content_type=_content_type,
                _headers=_headers,
                _host_index=_host_index,
            )
        )

        form = {}
        keep_empty_params = False

        request, error = await self._request_executor.create_request(
            method, url, body, header_params, form, keep_empty_params=keep_empty_params
        )

        if error:
            return (None, error)

        response, response_body, error = await self._request_executor.execute(request)

        if response_body == "" or response.status == 204:
            response_data = RESTResponse(response)
            resp = ApiResponse(
                status_code=response_data.status,
                data=None,
                headers=response_data.getheaders(),
                raw_data=b"",
            )
            return (None, resp, None)
        else:
            response_body = response_body.encode("utf-8")

            if error:
                return (response, error)

            response_data = RESTResponse(response)
            response_data.read(response_body)
            resp = self.response_deserialize(
                response_data=response_data,
                response_types_map=_response_types_map,
            )
            return (resp.data, resp, None)

    def _unassign_application_from_group_serialize(
        self,
        app_id,
        group_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if app_id is not None:
            _path_params["appId"] = app_id
        if group_id is not None:
            _path_params["groupId"] = group_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.select_header_accept(["application/json"])

        # authentication setting
        _auth_settings: List[str] = ["apiToken", "oauth2"]

        return self.param_serialize(
            method="DELETE",
            resource_path="/api/v1/apps/{appId}/groups/{groupId}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )
