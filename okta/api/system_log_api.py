# The Okta software accompanied by this notice is provided pursuant to the following terms:
# Copyright Â© 2025-Present, Okta, Inc.
# Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
# License.
# You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.
# Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS
# IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and limitations under the License.
# coding: utf-8

"""
Okta Admin Management

Allows customers to easily access the Okta Management APIs

The version of the OpenAPI document: 5.1.0
Contact: devex-public@okta.com
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""  # noqa: E501

from typing import Any, Dict, Tuple, Union
from typing import List, Optional

from pydantic import Field, StrictInt, StrictStr
from pydantic import validate_call, StrictFloat
from typing_extensions import Annotated

from okta.api_client import ApiClient, RequestSerialized
from okta.api_response import ApiResponse
from okta.models.log_event import LogEvent
from okta.models.success import Success
from okta.rest import RESTResponse


class SystemLogApi(ApiClient):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, configuration) -> None:
        super().__init__(configuration=configuration)

    @validate_call
    async def list_log_events(
        self,
        since: Annotated[
            Optional[StrictStr],
            Field(
                description="Filters the lower time bound of the log events `published` property for bounded queries or "
                            "persistence time for polling queries"
            ),
        ] = None,
        until: Annotated[
            Optional[StrictStr],
            Field(
                description="Filters the upper time bound of the log events `published` property for bounded queries or "
                            "persistence time for polling queries."
            ),
        ] = None,
        after: Annotated[
            Optional[StrictStr],
            Field(
                description="Retrieves the next page of results. Okta returns a link in the HTTP Header (`rel=next`) that "
                            "includes the after query parameter"
            ),
        ] = None,
        filter: Annotated[
            Optional[StrictStr],
            Field(
                description="Filter expression that filters the results. All operators except [ ] are supported. See [Filter]("
                            "https://developer.okta.com/docs/api/#filter) and [Operators]("
                            "https://developer.okta.com/docs/api/#operators)."
            ),
        ] = None,
        q: Annotated[
            Optional[StrictStr],
            Field(
                description="Filters log events results by one or more case insensitive keywords."
            ),
        ] = None,
        limit: Annotated[
            Optional[StrictInt],
            Field(
                description="Sets the number of results that are returned in the response"
            ),
        ] = None,
        sort_order: Annotated[
            Optional[StrictStr],
            Field(
                description="The order of the returned events that are sorted by the `published` property"
            ),
        ] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]
            ],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[LogEvent]:
        """List all System Log events

        Lists all System Log events  See [System Log query](https://developer.okta.com/docs/reference/system-log-query/) for
        further details and examples, and [System Log filters and search](
        https://help.okta.com/okta_help.htm?type=oie&id=csh-syslog-filters) for common use cases.  By default,
        100 System Log events are returned. If there are more events, see the [header link](
        https://developer.okta.com/docs/api/#link-header) for the `next` link, or increase the number of returned objects
        using the `limit` parameter.  >**Note:** The value of the `clientSecret` property in the System Log is secured by a
        hashing function, and isn't the value used during authentication.

        :param since: Filters the lower time bound of the log events `published` property for bounded queries or persistence
        time for polling queries
        :type since: str
        :param until: Filters the upper time bound of the log events `published` property for bounded queries or persistence
        time for polling queries.
        :type until: str
        :param after: Retrieves the next page of results. Okta returns a link in the HTTP Header (`rel=next`) that includes
        the after query parameter
        :type after: str
        :param filter: Filter expression that filters the results. All operators except [ ] are supported. See [Filter](
        https://developer.okta.com/docs/api/#filter) and [Operators](https://developer.okta.com/docs/api/#operators).
        :type filter: str
        :param q: Filters log events results by one or more case insensitive keywords.
        :type q: str
        :param limit: Sets the number of results that are returned in the response
        :type limit: int
        :param sort_order: The order of the returned events that are sorted by the `published` property
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "List[LogEvent]",
            "400": "Error",
            "403": "Error",
            "429": "Error",
        }

        method, url, header_params, body, post_params = self._list_log_events_serialize(
            since=since,
            until=until,
            after=after,
            filter=filter,
            q=q,
            limit=limit,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        form = {}
        keep_empty_params = False

        request, error = await self._request_executor.create_request(
            method, url, body, header_params, form, keep_empty_params=keep_empty_params
        )

        if error:
            if List[LogEvent] is Success:
                return (None, error)
            else:
                return (None, None, error)

        if List[LogEvent] is Success:
            response, response_body, error = await self._request_executor.execute(
                request
            )
        else:
            response, response_body, error = await self._request_executor.execute(
                request, LogEvent
            )

        if response_body == "" or response.status == 204:
            response_data = RESTResponse(response)
            resp = ApiResponse(
                status_code=response_data.status,
                data=None,
                headers=response_data.getheaders(),
                raw_data=b"",
            )
            return (None, resp, None)
        else:
            response_body = response_body.encode("utf-8")

            if error:
                if List[LogEvent] is Success:
                    return (response, error)
                else:
                    return (None, response, error)

            response_data = RESTResponse(response)
            response_data.read(response_body)
            resp = self.response_deserialize(
                response_data=response_data,
                response_types_map=_response_types_map,
            )
            return (resp.data, resp, None)

    def _list_log_events_serialize(
        self,
        since,
        until,
        after,
        filter,
        q,
        limit,
        sort_order,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if since is not None:
            _query_params.append(("since", since))

        if until is not None:
            _query_params.append(("until", until))

        if after is not None:
            _query_params.append(("after", after))

        if filter is not None:
            _query_params.append(("filter", filter))

        if q is not None:
            _query_params.append(("q", q))

        if limit is not None:
            _query_params.append(("limit", limit))

        if sort_order is not None:
            _query_params.append(("sortOrder", sort_order))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        _header_params["Accept"] = self.select_header_accept(["application/json"])

        # authentication setting
        _auth_settings: List[str] = ["apiToken", "oauth2"]

        return self.param_serialize(
            method="GET",
            resource_path="/api/v1/logs",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )
