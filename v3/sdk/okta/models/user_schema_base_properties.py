# coding: utf-8

"""
    Okta Admin Management

    Allows customers to easily access the Okta Management APIs

    The version of the OpenAPI document: 5.1.0
    Contact: devex-public@okta.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field
from typing import Any, ClassVar, Dict, List, Optional
from okta.models.user_schema_attribute import UserSchemaAttribute
from typing import Optional, Set
from typing_extensions import Self

class UserSchemaBaseProperties(BaseModel):
    """
    UserSchemaBaseProperties
    """ # noqa: E501
    city: Optional[UserSchemaAttribute] = None
    cost_center: Optional[UserSchemaAttribute] = Field(default=None, alias="costCenter")
    country_code: Optional[UserSchemaAttribute] = Field(default=None, alias="countryCode")
    department: Optional[UserSchemaAttribute] = None
    display_name: Optional[UserSchemaAttribute] = Field(default=None, alias="displayName")
    division: Optional[UserSchemaAttribute] = None
    email: Optional[UserSchemaAttribute] = None
    employee_number: Optional[UserSchemaAttribute] = Field(default=None, alias="employeeNumber")
    first_name: Optional[UserSchemaAttribute] = Field(default=None, alias="firstName")
    honorific_prefix: Optional[UserSchemaAttribute] = Field(default=None, alias="honorificPrefix")
    honorific_suffix: Optional[UserSchemaAttribute] = Field(default=None, alias="honorificSuffix")
    last_name: Optional[UserSchemaAttribute] = Field(default=None, alias="lastName")
    locale: Optional[UserSchemaAttribute] = None
    login: Optional[UserSchemaAttribute] = None
    manager: Optional[UserSchemaAttribute] = None
    manager_id: Optional[UserSchemaAttribute] = Field(default=None, alias="managerId")
    middle_name: Optional[UserSchemaAttribute] = Field(default=None, alias="middleName")
    mobile_phone: Optional[UserSchemaAttribute] = Field(default=None, alias="mobilePhone")
    nick_name: Optional[UserSchemaAttribute] = Field(default=None, alias="nickName")
    organization: Optional[UserSchemaAttribute] = None
    postal_address: Optional[UserSchemaAttribute] = Field(default=None, alias="postalAddress")
    preferred_language: Optional[UserSchemaAttribute] = Field(default=None, alias="preferredLanguage")
    primary_phone: Optional[UserSchemaAttribute] = Field(default=None, alias="primaryPhone")
    profile_url: Optional[UserSchemaAttribute] = Field(default=None, alias="profileUrl")
    second_email: Optional[UserSchemaAttribute] = Field(default=None, alias="secondEmail")
    state: Optional[UserSchemaAttribute] = None
    street_address: Optional[UserSchemaAttribute] = Field(default=None, alias="streetAddress")
    timezone: Optional[UserSchemaAttribute] = None
    title: Optional[UserSchemaAttribute] = None
    user_type: Optional[UserSchemaAttribute] = Field(default=None, alias="userType")
    zip_code: Optional[UserSchemaAttribute] = Field(default=None, alias="zipCode")
    __properties: ClassVar[List[str]] = ["city", "costCenter", "countryCode", "department", "displayName", "division", "email", "employeeNumber", "firstName", "honorificPrefix", "honorificSuffix", "lastName", "locale", "login", "manager", "managerId", "middleName", "mobilePhone", "nickName", "organization", "postalAddress", "preferredLanguage", "primaryPhone", "profileUrl", "secondEmail", "state", "streetAddress", "timezone", "title", "userType", "zipCode"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of UserSchemaBaseProperties from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of city
        if self.city:
            _dict['city'] = self.city.to_dict()
        # override the default output from pydantic by calling `to_dict()` of cost_center
        if self.cost_center:
            _dict['costCenter'] = self.cost_center.to_dict()
        # override the default output from pydantic by calling `to_dict()` of country_code
        if self.country_code:
            _dict['countryCode'] = self.country_code.to_dict()
        # override the default output from pydantic by calling `to_dict()` of department
        if self.department:
            _dict['department'] = self.department.to_dict()
        # override the default output from pydantic by calling `to_dict()` of display_name
        if self.display_name:
            _dict['displayName'] = self.display_name.to_dict()
        # override the default output from pydantic by calling `to_dict()` of division
        if self.division:
            _dict['division'] = self.division.to_dict()
        # override the default output from pydantic by calling `to_dict()` of email
        if self.email:
            _dict['email'] = self.email.to_dict()
        # override the default output from pydantic by calling `to_dict()` of employee_number
        if self.employee_number:
            _dict['employeeNumber'] = self.employee_number.to_dict()
        # override the default output from pydantic by calling `to_dict()` of first_name
        if self.first_name:
            _dict['firstName'] = self.first_name.to_dict()
        # override the default output from pydantic by calling `to_dict()` of honorific_prefix
        if self.honorific_prefix:
            _dict['honorificPrefix'] = self.honorific_prefix.to_dict()
        # override the default output from pydantic by calling `to_dict()` of honorific_suffix
        if self.honorific_suffix:
            _dict['honorificSuffix'] = self.honorific_suffix.to_dict()
        # override the default output from pydantic by calling `to_dict()` of last_name
        if self.last_name:
            _dict['lastName'] = self.last_name.to_dict()
        # override the default output from pydantic by calling `to_dict()` of locale
        if self.locale:
            _dict['locale'] = self.locale.to_dict()
        # override the default output from pydantic by calling `to_dict()` of login
        if self.login:
            _dict['login'] = self.login.to_dict()
        # override the default output from pydantic by calling `to_dict()` of manager
        if self.manager:
            _dict['manager'] = self.manager.to_dict()
        # override the default output from pydantic by calling `to_dict()` of manager_id
        if self.manager_id:
            _dict['managerId'] = self.manager_id.to_dict()
        # override the default output from pydantic by calling `to_dict()` of middle_name
        if self.middle_name:
            _dict['middleName'] = self.middle_name.to_dict()
        # override the default output from pydantic by calling `to_dict()` of mobile_phone
        if self.mobile_phone:
            _dict['mobilePhone'] = self.mobile_phone.to_dict()
        # override the default output from pydantic by calling `to_dict()` of nick_name
        if self.nick_name:
            _dict['nickName'] = self.nick_name.to_dict()
        # override the default output from pydantic by calling `to_dict()` of organization
        if self.organization:
            _dict['organization'] = self.organization.to_dict()
        # override the default output from pydantic by calling `to_dict()` of postal_address
        if self.postal_address:
            _dict['postalAddress'] = self.postal_address.to_dict()
        # override the default output from pydantic by calling `to_dict()` of preferred_language
        if self.preferred_language:
            _dict['preferredLanguage'] = self.preferred_language.to_dict()
        # override the default output from pydantic by calling `to_dict()` of primary_phone
        if self.primary_phone:
            _dict['primaryPhone'] = self.primary_phone.to_dict()
        # override the default output from pydantic by calling `to_dict()` of profile_url
        if self.profile_url:
            _dict['profileUrl'] = self.profile_url.to_dict()
        # override the default output from pydantic by calling `to_dict()` of second_email
        if self.second_email:
            _dict['secondEmail'] = self.second_email.to_dict()
        # override the default output from pydantic by calling `to_dict()` of state
        if self.state:
            _dict['state'] = self.state.to_dict()
        # override the default output from pydantic by calling `to_dict()` of street_address
        if self.street_address:
            _dict['streetAddress'] = self.street_address.to_dict()
        # override the default output from pydantic by calling `to_dict()` of timezone
        if self.timezone:
            _dict['timezone'] = self.timezone.to_dict()
        # override the default output from pydantic by calling `to_dict()` of title
        if self.title:
            _dict['title'] = self.title.to_dict()
        # override the default output from pydantic by calling `to_dict()` of user_type
        if self.user_type:
            _dict['userType'] = self.user_type.to_dict()
        # override the default output from pydantic by calling `to_dict()` of zip_code
        if self.zip_code:
            _dict['zipCode'] = self.zip_code.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of UserSchemaBaseProperties from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "city": UserSchemaAttribute.from_dict(obj["city"]) if obj.get("city") is not None else None,
            "costCenter": UserSchemaAttribute.from_dict(obj["costCenter"]) if obj.get("costCenter") is not None else None,
            "countryCode": UserSchemaAttribute.from_dict(obj["countryCode"]) if obj.get("countryCode") is not None else None,
            "department": UserSchemaAttribute.from_dict(obj["department"]) if obj.get("department") is not None else None,
            "displayName": UserSchemaAttribute.from_dict(obj["displayName"]) if obj.get("displayName") is not None else None,
            "division": UserSchemaAttribute.from_dict(obj["division"]) if obj.get("division") is not None else None,
            "email": UserSchemaAttribute.from_dict(obj["email"]) if obj.get("email") is not None else None,
            "employeeNumber": UserSchemaAttribute.from_dict(obj["employeeNumber"]) if obj.get("employeeNumber") is not None else None,
            "firstName": UserSchemaAttribute.from_dict(obj["firstName"]) if obj.get("firstName") is not None else None,
            "honorificPrefix": UserSchemaAttribute.from_dict(obj["honorificPrefix"]) if obj.get("honorificPrefix") is not None else None,
            "honorificSuffix": UserSchemaAttribute.from_dict(obj["honorificSuffix"]) if obj.get("honorificSuffix") is not None else None,
            "lastName": UserSchemaAttribute.from_dict(obj["lastName"]) if obj.get("lastName") is not None else None,
            "locale": UserSchemaAttribute.from_dict(obj["locale"]) if obj.get("locale") is not None else None,
            "login": UserSchemaAttribute.from_dict(obj["login"]) if obj.get("login") is not None else None,
            "manager": UserSchemaAttribute.from_dict(obj["manager"]) if obj.get("manager") is not None else None,
            "managerId": UserSchemaAttribute.from_dict(obj["managerId"]) if obj.get("managerId") is not None else None,
            "middleName": UserSchemaAttribute.from_dict(obj["middleName"]) if obj.get("middleName") is not None else None,
            "mobilePhone": UserSchemaAttribute.from_dict(obj["mobilePhone"]) if obj.get("mobilePhone") is not None else None,
            "nickName": UserSchemaAttribute.from_dict(obj["nickName"]) if obj.get("nickName") is not None else None,
            "organization": UserSchemaAttribute.from_dict(obj["organization"]) if obj.get("organization") is not None else None,
            "postalAddress": UserSchemaAttribute.from_dict(obj["postalAddress"]) if obj.get("postalAddress") is not None else None,
            "preferredLanguage": UserSchemaAttribute.from_dict(obj["preferredLanguage"]) if obj.get("preferredLanguage") is not None else None,
            "primaryPhone": UserSchemaAttribute.from_dict(obj["primaryPhone"]) if obj.get("primaryPhone") is not None else None,
            "profileUrl": UserSchemaAttribute.from_dict(obj["profileUrl"]) if obj.get("profileUrl") is not None else None,
            "secondEmail": UserSchemaAttribute.from_dict(obj["secondEmail"]) if obj.get("secondEmail") is not None else None,
            "state": UserSchemaAttribute.from_dict(obj["state"]) if obj.get("state") is not None else None,
            "streetAddress": UserSchemaAttribute.from_dict(obj["streetAddress"]) if obj.get("streetAddress") is not None else None,
            "timezone": UserSchemaAttribute.from_dict(obj["timezone"]) if obj.get("timezone") is not None else None,
            "title": UserSchemaAttribute.from_dict(obj["title"]) if obj.get("title") is not None else None,
            "userType": UserSchemaAttribute.from_dict(obj["userType"]) if obj.get("userType") is not None else None,
            "zipCode": UserSchemaAttribute.from_dict(obj["zipCode"]) if obj.get("zipCode") is not None else None
        })
        return _obj


